{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"泥嚎呀( •̀ ω •́ )y","text":"这里是嘉维小站，我是王嘉维。在大学时候偶然接触到了腾讯云学生一元优惠主机，便心痒想建一个属于自己的网站，于是在域名主机一条龙以后，这个网站就诞生了。但2016年建站以后随着三分钟热度过去，这个站点也慢慢荒废了。2018年大学毕业，随着学生身份结束，腾讯云立马结束了我的一元主机优惠权限（这头刚刚参加完毕业典礼那头腾讯云就发邮件说失去身份了，辣鸡TX），于是立即动手将博客移动到Bandwagon VPS上去，再见了您呐，腾讯云主机。在整理硬盘的时候发现了许多好玩的小玩意，心想也许是时候重启站点了。于是换个主题，开始了嘉维小站2.0时代！在以后的日子里，接触到酷炫的事物之后会把他们一一整理之后发上来，希望大家会喜欢！ 如果你读到了这里，真的让我太感动了QAQ。作为回报，我在这里埋下了一个小彩蛋：vmess 相信聪明的你一定知道这个怎么用( ͡° ͜ʖ ͡°) [Unreleased]Added 计划将课堂笔记也更新至本站中。由于大多是英文笔记因此会计划更新至英文站中。敬请期待！· 由于感觉Evernote命不久矣，因此计划将Evernote上的笔记转移至小站中。即将更新LeetCode刷题记录！ [2.3.1] - 2019-09-16Changed 主题从 NexT.Gemini 更换至更耐看的 Icarus。 [2.3.0] - 2019-09-14Changed 拥抱Github Pages平台！ [2.2.0] - 2018-08-08Added 增添TLSv1.3传输层安全协议支持(draft-28)。 增添h2传输协议支持。 增添gzip压缩套件支持。 增添brotli压缩套件支持。 增添谷歌浏览器“证书透明度 (Certificate Transparancy)”支持。 Changed nginx版本从1.13.3更新到1.15.2。 [2.1.0] - 2018-08-06Changed 对原始主题做了大幅修改，“夜间模式”上线！ [2.0.2] - 2018-08-04Changed 传输层安全协议中去除了不安全的SSL3、TLSv1协议，增添了TLSv1.2的支持。 [2.0.1] - 2018-08-03Added 修改了网站的结构，从原来的article/xxx.html变成[language]/xxx.html，使得能够兼容以后可能会出现的多语言文章。 [2.0.0] - 2018-08-03Added 创建了“关于”页面，添加了一个符合Keep A Changelog规范的更新日志，用于记录站点的更新历史。 Changed 更换了服务器主机。 hexo版本从v3.6.2更新至v3.7.1。 主题从Hueman更换至NexT.Gemini。 [1.2.0] - 2017-03-04Changed 博客系统从Wordpress更换为hexo。相关文章 [1.1.0] - 2017-02-28Added 部署了Let’s Encrypt SSL证书，正式开启全站HTTPS模式。相关文章 [1.0.0] - 2016-04-01Added 成功申请域名和备案，嘉维小站正式建站了！","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"LeetCode 刷题记录: 101. Symmetric Tree [Python]","text":"原题 https://leetcode.com/problems/symmetric-tree/ Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). 思路递归判断左节点的左边是否等于右节点的右边。 代码123456789101112131415# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root: TreeNode) -&gt; bool: def isSym(L,R): if not L and not R: return True if L and R and L.val==R.val: return isSym(L.left,R.right) and isSym(L.right,R.left) return isSym(root,root)","link":"/zh-CN/LC101_Symmetric_Tree.html"},{"title":"拖延症的救星！如何使用2Do打造一个实用的GTD®工具","text":"作为一个拖延症晚期的选手，经常视deadline为第一生产力，不到最后一分钟坚决不做事¯\\_(ツ)_/¯。这使得在日常生活中，经常会将一骡子未完成的事情记在脑子中。再加上经常忘事的属性，久而久之就会将一些需要做的事情彻底遗忘在脑海中，不得不说深受其害。我曾经非常希望能够改掉忘记完成事情的这个坏毛病，理论上来说，遇到事情第一时间完成便是最好的了。但是，拖延症是改不了的。这辈子也改不了的。那么，如何改变这样的现状呢？正在挠头之际，GTD®出现了。 GTD®（又称“尽管去做”，Getting Things Done®) 源自David Allen的同名书籍，是一种行为管理的方法。这种方法要求个人将目前正在进行的所有工作以及任务使用 记录 的方式（通过纸笔、电子设备等）从头脑中移出来，使得这些外部设备充当 “第二大脑”，让自己 不再需要在进行一项工作的同时惦记着其他未完成的工作，从而能够专心致志地完成当前的工作，在同时面对一大堆工作的时候也能够有条不紊地处理。 不过，GTD®所承担的“第二大脑”，又和印象笔记所推崇的“第二大脑”有一定区别。在印象笔记中，“第二大脑”所承担的任务是让外部设备辅助记下各种生活中的资料以及想法，而GTD®的作用则更像是RPG游戏中的“任务列表”：让外部设备来辅助记下目前以及以后需要做的工作。也许有人会说，这不就是Todo嘛，是的，但又不是。其实GTD®不过是经过改造的一种Todo的使用方式。但这种新的使用方式却让Todo的效率有了极大提高。也因为如此，只要有一款上手的Todo应用，经过些许调整就能够无缝转换到GTD®的方式来，转换成本非常低。 对于第一次接触GTD®的人来说，最全面的入门方式当然就是去看原著。网上也有中文的翻译版本可以参考。不过原书由于出版的年代比较久远，使用的是比较原始的纸张记录的方式，对于互联网以及无纸化办公普及的今天相比有些落后。对于没有碰过纸笔快一年的我来说，再用回硬核的笔记本的方法实在太麻烦了。万幸的是手机里还藏着一款Todo应用—— 2Do。因此在读完全书以后，我尝试将书中的概念逐一映射到2Do里面，总结了一套使用2Do作为GTD®工具的方案。经过两三个月的修改以及使用，自以为这套方法已经进化得比较成熟了，所以在这里放出来给大家参考一下。 GTD® on 2Do 2Do是一款比较全面的Todo类应用。它支持iOS/Mac/Android三种平台，可以添加任务(Task)、项目(Project)、以及清单(Checklist)三种任务类别，并且能够为每项任务标记标签(Tags)；在分类功能中，2Do支持进行分类的一般列表(List)，以及最重要的 智能列表(Smart List) 。智能列表实际上是一个可保存筛选参数的筛选器，他可以从所有任务中按照条件筛选出符合要求的任务并且展示出来。通过创建一系列智能列表我们就可以得到一系列内容随任务状态而改变的动态列表，这也是在这套方法中GTD®能够实现的基础。具体的细节会在实际操作中进行演示。 Inbox 从上图可以看出，在GTD®的概念中，所有的想法（以及工作，以及任务）首先应该去到的地方应该是”In”，也就是 Inbox 。意思是说，当脑海中突然闪现某种想法的时候，或者有一大堆任务等待着倾诉的时候，应当第一时间把它们扔进 Inbox 区域中。不过在这里，与一般Todo记录事件的方式不同在于，GTD®不要求第一时间将添加进来的记录进行分类。Inbox作为事件的缓冲区域，所有进来的内容无需做任何处理，直接扔进来就好了。因此可以看到我的 Inbox 区域基本上是杂乱无章的。 因此，制定一个专门的时间用于整理 Inbox 中的内容显得尤其重要。在整理的时候，首先需要制定一个规则。必须从上往下，或从下往上处理所有当前的内容，而不允许有跳过的情况。这一点Allen在书中曾明确要求过，就是为了杜绝积压的现象出现。因为假如有一条记录一直压在Inbox中从来不去处理，那么久而久之就会习惯积压事件，那么 Inbox 就失去了作为 事件缓冲区 的意义。 下一步是什么？对于事件的整理部分，GTD®制定了一系列要求。对于每一条记录，首先应当考虑的是“下一步是什么？”。比如上面截图中的某一条记录Blog for 2Do: 因为Blog for 2Do是一个工作，因此GTD®要求列出这个工作的接下来需要进行的具体操作： 为2Do写博客： 新建一份Markdown文档 查找GTD资料 在2Do中新建一份适当的演示用事件 提前操作一遍并记录实际操作 整理最终文档 发布博客 因此，我将这条记录的类别由默认的任务(Task)变成项目(Project)。在2Do中，一个项目中可以包含多个任务，因此很适合用来记录 下一步动作。 值得一提的是，原始GTD®只需要考虑这份工作的 下一步动作(Next Action) 是什么，注意是Action而不是Actions。因此理论上一个工作的列表中最后一项就是当前需要完成的下一步动作，完成一项动作之后再继续记录下一项。但是我习惯于一次性把所有步骤都考虑好，只记录一项只会让我在脑海里不断地演绎下一步下一步。。。反而更加让我寝食不安了。因此我把所有步骤都记录下来了。如果习惯一步一步来的同学也可以使用GTD®的正统做法，只记录一步。 当然2Do的标签功能告诉我，这不要紧。好奇的同学可以继续看下去:) 接下来，GTD®要求将这份工作按照使用场景作分类。在2Do中，可以简单地使用一般列表(List)对各个场景进行分类。对于 能够进行操作的任务，我目前分有个人(Personal)以及工作(Work)两个类别。对于 不能立即进行 的任务，我设置了稍后阅读(Read later)以及点子/以后再做(Ideas/someday)两个类别。因此写博客的任务便分配到了个人列表中。 有的人产生想法的频率很快，Inbox很快就塞满了，因此这些人可能需要早中晚分别整理一次。对于我来说，每天中午整理一次也许就够了。在空闲的时间没事就拿出手机整理当前的想法也是一种很好的方式。 下一步怎么做？制定了事件的 下一步动作 以后，我们需要进一步考虑这个动作是属于以下哪个方面的： Do it! - 如果这个动作小于两分钟而且现在能够完成的话，不需任何标记，立刻就去做！ Delayed - 如果这个动作要到特定某个日期才能完成，这就是 滞后(Delayed) 状态。 Await - 如果这个动作需要委托他人完成，那么就是 等待(Await/Waiting For) 状态。 Next - 如果这个动作不属于上面的每一项，或者当前条件不允许立刻完成的，那么这个动作就要放入你的 下一步动作(Next Actions) 列表了。记录下来，在合适的时候完成它！ 在2Do中，有一项非常实用的功能：标签(Tags)。通过标签我们就可以将每一个动作使用next，await以及delayed三个标签作为标记。如果你使用的是原始GTD®的做法，一次只记录一项内容，那么你可以很轻松地、直接对这项动作进行标记。如果你和我一样，是习惯于提前规划一切的选手，那么请记住，只对第一项动作进行标记。（已完成的任务请直接通过app标记已完成，这样的话就能够保证最上面的动作就是当前需要进行的下一步动作。） 经过几个月的使用，我给自己制定了一套比较合理的标记规则，目前使用上是比较舒服的： next - 意味着直接的下一步动作。永远记得需要对工作列表最上面的一项没有任何标记的内容标记上next。 await - 当一项动作因为外部因素目前无法继续进展的，且不知道明确完成时间的（比如正在等待别人答复的事情），标记上await，并且在note的地方记录下不能完成的原因，使得在检查列表的时候能够快速记起这件事情为什么正在处于等待状态。 delayed - 当一项动作因为自身的理由暂时搁置的（比如“需要等到出国前一天再开通国际漫游服务”等等），则需要标记上delayed，并且需要标记上截止时间（使得app能够在当天及时提醒你继续进行操作）。 动作列表有同学会说，标记了以后如何查看呢？在这里隆重介绍2Do最引以为傲的功能——智能列表(Smart List)。正如之前所提到的，智能列表实际上就是保存了筛选参数的筛选器。因此我们只需要选出包含动作标记的任务，便能立刻创造出各个标记专属的列表了。对于需要关注的 下一步动作 列表，我们可以建立一个筛选器，提取出所有标签为next的就好了： 1tags: next 可以看到，我们刚刚标记的Finish the doc动作也包含在其中了。同样地，await，delayed标签同样也可以使用这种方式创立属于不同状态的专属列表： 12tags: awaittags: delayed 检查内容添加内容固然很重要，但即时检查并且回顾工作进展也是非常重要的一项工作。需要约定一个固定时间定期对所有列表中的工作进行检查。检查有没有新的下一步动作没有进行标记的，或者哪一些滞后或者等待的内容现在可以继续进行下去的。对于我来说，每天熄灯睡觉在床上玩手机的时候就是一个最佳的回顾时间。 至此，GTD®所要求的所有标准都成功移植进2Do应用里了！简单吧，GTD®本身一点都不复杂。但使用上GTD®以后，给生活带来的便利确是巨大的。至少在使用了两三个月以后，尽管因为拖延症，当前需要同时进行的工作再多，脑子里也不会一直环绕着各种未完成事项的提醒了，处理事情的时候也能够心无旁骛了。至少，因为不会忘记处理任何滞后的事情，拖延症也不再有副作用了！！","link":"/zh-CN/2do.html"},{"title":"LeetCode 刷题记录: 19. Remove Nth Node From End of List [Python]","text":"原题 https://leetcode.com/problems/remove-nth-node-from-end-of-list/ Given a linked list, remove the n-th node from the end of list and return its head. Follow up: Could you do this in one pass? 思路使用两个指针fast以及slow，fast先出发，slow相隔n位再出发。当fast走到尽头时slow跳过下一指针即可。 代码12345678910111213141516171819# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: slow=fast=self self.next=head while fast.next: if n: n-=1 else: slow=slow.next fast=fast.next slow.next=slow.next.next return self.next","link":"/zh-CN/LC19_Remove_Nth_Node_From_End_of_List.html"},{"title":"LeetCode 刷题记录: 11. Container With Most Water [Python]","text":"原题 https://leetcode.com/problems/container-with-most-water/ Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). nvertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note: You may not slant the container and n is at least 2. 思路贪心算法，从左右两边开始，从短的一边往中间缩进并记录最大值。由于短板效应从短的一边往中间缩进是最有利的。 代码12345678910class Solution: def maxArea(self, height: List[int]) -&gt; int: l,r,m=0,len(height)-1,-1 while(l&lt;r): m=max(m,min(height[l],height[r])*(r-l)) if height[l]&lt;height[r]: l+=1 else: r-=1 return m","link":"/zh-CN/LC11_Container_With_Most_Water.html"},{"title":"LeetCode 刷题记录: 1. Two Sum [Java]","text":"原题 https://leetcode.com/problems/two-sum/ Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. 思路使用hashmap查表，拿到数字首先查找余值是否在表内，若在的话直接返回表内的对应值。接着将数字以及index存入表内。 代码1234567891011121314import java.util.HashMap;class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer, Integer&gt; h = new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++){ int residue=target-nums[i]; if(h.containsKey(residue)){ return new int[]{h.get(residue),i}; } h.put(nums[i],i); } throw new IllegalArgumentException(\"No solution\"); }}","link":"/zh-CN/LC1_Two_Sum.html"},{"title":"LeetCode 刷题记录: 31. Next Permutation [Python]","text":"原题 https://leetcode.com/problems/next-permutation/ Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 思路 指针i从后往前找到第一个前面比后面小的数nums[i-1]，此时i:end均为从大到小排序。 指针j从后往前找到第一个比nums[i-1]大的数nums[j]。此时nums[j]为i:end中的最小数。 交换nums[i-1]与nums[j]，此时i:end依然为从大到小排序。 将i:end倒序，此时变成从小到大排序。完成。 代码123456789101112131415class Solution: def nextPermutation(self, nums: List[int]) -&gt; None: \"\"\" Do not return anything, modify nums in-place instead. \"\"\" n=len(nums) if n&lt;2: return i=j=n-1 while i&gt;0 and nums[i-1]&gt;=nums[i]: i-=1 if i&gt;0: while nums[j]&lt;=nums[i-1]: j-=1 nums[i-1],nums[j]=nums[j],nums[i-1] nums[i:]=reversed(nums[i:])","link":"/zh-CN/LC31_Next_Premutation.html"},{"title":"LeetCode 刷题记录: 22. Generate Parentheses [Python]","text":"原题 https://leetcode.com/problems/generate-parentheses/ Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. 思路使用动态规划，分析子问题：每次加括号要么加在外面，要么加在旁边。 代码12345678class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: dp=[[] for i in range(n+1)] dp[0].append('') for i in range(n+1): for j in range(i): dp[i]+=['('+inner+')'+outer for inner in dp[j] for outer in dp[i-j-1]] return dp[n]","link":"/zh-CN/LC22_Generate_Parentheses.html"},{"title":"LeetCode 刷题记录: 46. Permutations [Python]","text":"原题 https://leetcode.com/problems/permutations/ Given a collection of distinct integers, return all possible permutations. 思路Backtrack。当temp长度等于所有数字时，添加进结果。否则遍历数字，每个数字添加进temp中，进行下一次迭代。当temp中存在相同数字时跳过。 代码1234567891011121314class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: if not nums: return [[]] result=[] self.backtrack(nums,[],result) return result def backtrack(self, nums, temp,result): if len(temp)==len(nums): result.append(temp[:]) else: for num in nums: if num in temp: continue temp.append(num) self.backtrack(nums,temp,result) temp.pop()","link":"/zh-CN/LC46_Permutations.html"},{"title":"LeetCode 刷题记录: 42. Trapping Rain Water [Python]","text":"原题 https://leetcode.com/problems/trapping-rain-water/ Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 思路使用双指针，分别从两头往最高处逼近。每次经过刷新左边和右边的最高值，该处结果等于最高值与当前值的差。 代码12345678910111213141516class Solution: def trap(self, height: List[int]) -&gt; int: res=0 left=0 right=len(height)-1 max_left=max_right=0 while left&lt;=right: if height[left]&lt;height[right]: max_left=max(max_left,height[left]) res+=max_left-height[left] left+=1 else: max_right=max(max_right,height[right]) res+=max_right-height[right] right-=1 return res","link":"/zh-CN/LC42_Trapping_Rain_Water.html"},{"title":"LeetCode 刷题记录: 48. Rotate Image [Python]","text":"原题 https://leetcode.com/problems/rotate-image/ You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. 思路先转置再x轴颠倒。 代码12345678910class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: \"\"\" Do not return anything, modify matrix in-place instead. \"\"\" for i in range(len(matrix)): for j in range(i): matrix[i][j],matrix[j][i]=matrix[j][i],matrix[i][j] for i in range(len(matrix)): matrix[i][:]=matrix[i][::-1]","link":"/zh-CN/LC48_Rotate_image.html"},{"title":"LeetCode 刷题记录: 56. Merge Intervals [Python]","text":"原题 https://leetcode.com/problems/merge-intervals/ Given a collection of intervals, merge all overlapping intervals. 思路先对数组排序，然后遍历数组。设定两个变量记录左边界和右边界。 对于每个范围，当其左值小于记录的右边界时，即这个范围可以被merge。此时右边界为右值与右边界的最大值，在结果数组更新最后一项的右值。 否则重新设定左边界与右边界，并将新的范围记录至结果中。 代码123456789101112131415class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: if len(intervals)==0: return [] left=right=-1 intervals.sort() res=[] for intv in intervals: if right&gt;=intv[0]: right=max(intv[1],right) res[-1][1]=right else: left,right=intv res.append(intv) return res","link":"/zh-CN/LC56_Merge_Intervals.html"},{"title":"LeetCode 刷题记录: 55. Jump Game [Python]","text":"原题 https://leetcode.com/problems/jump-game/ Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. 思路设定一个变量reachable记录当前能够达到的最远值。然后遍历nums: 当reachable&lt;i时，即已经不能到达该处。返回False。 否则更新reachable，大小为当前能走的最远值以及此处可以走的最远值之间的最大值。 接着判断reachable是否大于nums，若是即可提前返回True跳出。 代码1234567class Solution: def canJump(self, nums: List[int]) -&gt; bool: reachable=0 for i in range(len(nums)): if reachable&lt;i:return False reachable=max(reachable,i+nums[i]) if reachable&gt;=len(nums)-1: return True","link":"/zh-CN/LC55_Jump_Game.html"},{"title":"LeetCode 刷题记录: 79. Word Search [Python]","text":"原题 https://leetcode.com/problems/word-search/ Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 思路DFS。四个方向搜寻即可。 代码1234567891011121314class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: if not board: return False for i in range(len(board)): for j in range(len(board[0])): if self.dfs(board,i,j,word): return True return False def dfs(self, board, i, j, word): if len(word)==0: return True if i&lt;0 or i&gt;=len(board) or j&lt;0 or j&gt;=len(board[0]) or word[0]!=board[i][j]: return False tmp,board[i][j]=board[i][j],'#' res=self.dfs(board,i-1,j,word[1:]) or self.dfs(board,i+1,j,word[1:]) or self.dfs(board,i,j-1,word[1:]) or self.dfs(board, i, j+1, word[1:]) board[i][j]=tmp return res","link":"/zh-CN/LC79_Word_Search.html"},{"title":"LeetCode 刷题记录: 84. Largest Rectangle in Histogram [Python]","text":"原题 https://leetcode.com/problems/largest-rectangle-in-histogram/ Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. 思路在height后面加上一个0作为右边界，记录高度堆栈stack加上一个-1作为左边界。遍历heights，若当前height不低于stack最后一个元素的高度时，添加进stack中。否则： 从堆栈中弹出最后一个元素，即当前最高处位置信息，获取该位置的高度。 以当前位置i作为右边界，当前堆栈的最后一个元素stack[-1]，即当前第二高的位置作为左边界，宽度则为右边界-左边界-1（边界均不包含在内），即w=i-stack[-1]-1。 此时矩形面积即为h*w。 代码12345678910111213class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: heights.append(0) stack=[-1] ans=0 for i in range(len(heights)): while heights[i]&lt;heights[stack[-1]]: h=heights[stack.pop()] w=i-stack[-1]-1 ans=max(ans,h*w) stack.append(i) heights.pop() return ans","link":"/zh-CN/LC84_Largest_Rectangle_in_Histogram.html"},{"title":"LeetCode 刷题记录: 96. Unique Binary Search Trees [Python]","text":"原题 https://leetcode.com/problems/unique-binary-search-trees/ Given n, how many structurally unique BST’s (binary search trees) that store values 1 … n? 思路对于n个值，以i为根，则可以将[1,i-1]放入左边，[i+1,n]放入右边，因此有[i-1]*[i-j]种方式。 代码12345678class Solution: def numTrees(self, n: int) -&gt; int: arr=[0]*(n+1) arr[0]=1 for i in range(1,n+1): for j in range(1,i+1): arr[i]+=arr[j-1]*arr[i-j] return arr[-1]","link":"/zh-CN/LC96_Unique_Binary_Search_Trees.html"},{"title":"LeetCode 刷题记录: 5. Longest Palindromic Substring [Python]","text":"原题 https://leetcode.com/problems/longest-palindromic-substring/ Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 思路马拉车方法 (Manacher’s Algorithm) 利用回文的性质减少运算。 考虑到回文中心可能位于两字符之间，将字符串之间的间隔使用符号（#）代替。 定义radius数组，记录每个位置的最大回文半径。 对于一个回文串的中心c，令R为这个回文串的右半径(R=c+radius[c])，即回文串范围为[c-R, c+R]。根据回文的性质，右半径内的字符 i（i-&gt;(c, c+R)）其回文半径与回文串左半径内的镜像字符 j（j=(2*c-i)）有关。当： j的回文范围在回文串范围以内时，i的回文与j的回文完全一致。 (radius[i]=radius[j]) j的回文范围在回文串范围以外时，只能确保i的回文范围在右半径R之内。 (radius[i]&gt;=R-i+1) 尝试扩展i的回文范围，考察T[i+radius[i]]==T[i-radius[i]]。若属于3.1情况将直接跳出。若属于3.2情况将扩大i的回文范围。 当i的回文范围大于右半径R时，将该位置作为中心(c=i)，定义右半径R(R=c+radius[c])，重复步骤345。记录radius以及回文串的最大值。所有位置遍历完后返回最大回文串。 代码1234567891011121314151617181920212223242526272829303132333435class Solution: \"\"\" @param s: input string @return: the longest palindromic substring \"\"\" def longestPalindrome(self, s): # write your code here if not s: return s T = '#' for c in s: T += c T += '#' radius = [0]*len(T) c, r = 0, -1 maxr, maxs = -1, '' for i in range(len(T)): if r &gt; i: j = c-i-c radius[i] = min(radius[j], c+r-1) while -1 &lt; i-radius[i] and i+radius[i] &lt; len(T): if T[i-radius[i]] == T[i+radius[i]]: radius[i] += 1 else: break if radius[i] &gt;= r: c, r = i, radius[i]-1 if r &gt; maxr: maxr = r maxs = s[(i-r)//2 : (i+r)//2] return maxs","link":"/zh-CN/LC5_Longest_Palindromic_Substring.html"},{"title":"LeetCode 刷题记录: 98. Validate Binary Search Tree [Python]","text":"原题 https://leetcode.com/problems/validate-binary-search-tree/ Given a binary tree, determine if it is a valid binary search tree (BST). 思路递归判断子节点: 当节点为None时，即到达分支底端，返回True即该条线正确。 当min存在且当前值小于min时，返回False。 当max存在且当前值大于max时，返回False。 当不存在min和max时，开始往两头搜索。左边：最小值维持原样，最大值为当前节点的值。右边：最大值维持原样，最小值为当前节点的值。 代码12345678910111213141516# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isValidBST(self, root: TreeNode) -&gt; bool: def search(root,mi,ma): if not root: return True if mi!=None and root.val&lt;=mi: return False if ma!=None and root.val&gt;=ma: return False return search(root.left,mi,root.val) and search(root.right,root.val,ma) return search(root,None,None)","link":"/zh-CN/LC98_Validate_Binary_Search_Tree.html"},{"title":"LeetCode 刷题记录: 85. Maximal Rectangle [Python]","text":"原题 https://leetcode.com/problems/maximal-rectangle/ Given a 2D binary matrix filled with 0’s and 1’s, find the largest rectangle containing only 1’s and return its area. 思路大致思路和 84. Largest Rectangle in Histogram 相同，对于每个row判断如果为1则高度叠加，否则高度清零。 代码1234567891011121314151617class Solution: def maximalRectangle(self, matrix: List[List[str]]) -&gt; int: if not matrix or not matrix[0]: return 0 height=[0] *(len(matrix[0])+1) ans=0 for row in matrix: for i in range(len(matrix[0])): height[i]=height[i]+1 if row[i]=='1' else 0 stack=[-1] for i in range(len(matrix[0])+1): while height[i]&lt;height[stack[-1]]: h=height[stack.pop()] w=i-stack[-1]-1 ans=max(ans,h*w) stack.append(i) return ans","link":"/zh-CN/LC85_Maximal_Rectangle.html"},{"title":"hexo小撇步：服务器架设hexo过程全记录","text":"刚一申请到域名和服务器，第一件事情便是架设博客。当时想找一个方便省事的博客框架，于是看到当时吹得天花乱坠的Wordpress，便不小心掉进了大坑。还没写几篇文章，便已经开始遭遇各种麻烦。最难忍的一点就是不知道为何载入极慢。网上说是由于自带google字库的原因，可是下载了好几个去字库插件变着花样试却都是徒劳（你可以想象在设置页面中顶着30秒以上一页的载入速度在插件页面苦苦寻找并一个一个尝试的滋味吗，那大概是地狱的滋味了）。而博客也因此处于长时间停更的状态（实在是没有心情写了）。 于是乎，趁着一次误删除操作的机会（把主页所在的文件夹整一个删掉了），我踏上了寻找更好的博客框架之路。于是乎，驻足在了HEXO面前。 之前看到很多有关于hexo的教程与内容，基本上都是关于如何在Github Pages中的部署，在服务器中部署的内容极少，所以一直没有认真地考虑过hexo的可行性。于是抱着试一试的态度重新审视了一遍hexo，发现他原来是一个生成静态站点的工具。而因为nginx拥有对静态页面的处理的特殊加成，于是两者一拍即合，浑然天成，当即决定使用hexo作为新的博客框架。 Hexo是一款由Node.js开发的博客框架。它的安装需要进行以下步骤： 安装Node.js 安装Hexo 安装Node.js安装之前，我们需要更新yum源： 1$ yum -y update 接下来，从官网下载Node.js的最新源码来进行编译安装。 首先我们需要安装用来进行编译操作的Development Tools： 1$ yum -y groupinstall &quot;Development Tools&quot; 接下来，进入用来编译源码的目录： 1$ cd /uer/local/src 现在可以准备开始下载Node.js的源码了： 1$ wget http://nodejs.org/dist/node-latest.tar.gz 等待下载完毕后，即可解压文件到当前目录： 12$ tar zxf node-*.tar.gz $ cd node-v* 准备进行编译： 1$ ./configure 等待几分钟配置好后，输入命令开始进行漫长的编译： 1$ make 期间编译的时间极长，伴随着满载的CPU和不断弹出的警告信息（是真的，满屏幕的警告信息）等待大概40~50分钟左右，编译结束, 开始进行正式安装Node.js： 1$ make install 安装的时间比编译时间要短一些，大概10分钟左右。安装完毕后，可以输入以下指令检查是否正确安装： 12$ node --version $ npm --version 安装HexoHexo使用的是npm进行安装。由于npm源的原因，在国内直接使用npm进行安装整个下载过程将会极其缓慢，苦不堪言。所以我在这里使用淘宝npm镜像来进行安装。 可以通过以下的方法更换npm使用的源： 1$ vim ~/.npmrc 使用vim打开该文件后，按i添加以下内容，输入:wq退出： 1registry = https://registry.npm.taobao.org 配置好源以后，我们可以开始安装hexo了： 1npm install hexo-cli -g 安装完毕以后，选择一个目录，使用以下指令对这个目录进行hexo初始化：（在这里，我选择/hexo作为我的hexo目录） 1$ hexo init /hexo 输入指令后，hexo开始往该目录下载hexo站点所需要的初始化文件。等待初始化完成后，这个目录就成为了我们的hexo站点目录了。当然，也可以在多个不同的地方建立不同的hexo站点目录，而所有不同地方生成的站点目录都是相互独立的。这有点像project的感觉。而所有对站点进行的操作都需要cd到站点所在的目录下进行。 那么我们现在进入/hexo目录内一探究竟： 12$ cd /hexo$ dir 可以看到，/hexo目录新增了许多文件。主要目录结构如下： 12345678.├── _config.yml （配置文件）├── package.json├── scaffolds├── source| ├── _drafts （草稿箱，在这里存放的文章不会被生成）| └── _posts （在这里存放的文章会被生成）└── themes （主题目录） _config.yml这是hexo站点的配置文件。具体的配置可以查看官网文档。 为了方便生成，我在配置文件中将public_dir的路径直接设置在nginx的网站根目录下。具体效果可以看看我写的另一篇文章（正在写）。 配置好后输入以下指令开始生成静态页面文件： 1$ hexo g 于是乎，新的博客站点已经建立好了。 如何写文章在本地使用任何支持Markdown格式的文本编辑器（个人推荐MarkdownPad2）建立一个.md文档来写文章。在文件的头部还需要填写一些信息，比如现在这篇文章就是使用如下的信息： 1234567---title: hexo小撇步：服务器架设hexo过程全记录date: 2017/3/4category: 编程tags: [hexo]thumbnail: https://hexo.io/logo.svg--- 文章写完后，将写好的.md文件上传至&lt;hexo站点目录&gt;/source/_posts，然后在站点目录下使用hexo g指令即可生成新的站点。整个站点将在指定的public_dir中生成。（这也就是我选择将该路径直接设置在网站根目录下的原因）","link":"/zh-CN/hexo-installment-log.html"},{"title":"给网站用上免费SSL：Let's Encrypt操作记录","text":"看着别人网站上绿色的https标签很是心痒，而又不想花大价钱申请企业级的SSL方案，于是寻思着给网站申请了一个免费的沃通CA证书。谁知道前脚刚刚部署完证书，后脚却在网上发现沃通证书将不再被信任，心里很不是滋味。于是便重新上网搜寻其他获得SSL的方法。经过短暂的搜寻，发现了这样一个免费的SSL证书授权机构(CA)： Let’s Encrypt 据官网介绍，Let’s Encrypt服务由Internet Security Research Group (ISRG)推出，通过向网站自动签发和管理免费SSL证书，旨在降低互联网进行安全通信的门槛。该项目托管于Linux基金会，得到了来自诸如Mozilla, Akamai, Cisco, Electronic Foundation Frontier, OVH.com, Google Chrome等大咖加持，来头实在不小。 为什么最终选择使用这个方案呢？首先当然是因为免费了。其次就是官网所宣传的“自动化(automated)”了。要知道当时给网站上CA证书的时候，生成私钥上传证书，各种麻烦事儿。Let’s Encrypt仅需要一条指令即可完成续签，根本不用进行文件操作，实在是极其吸引人。 不多说废话，立刻进行操作。 本文使用CentOS 7+Nginx的组合。 注意：不同的OS和Web服务器所使用的命令不尽相同，有关其他系统和Web服务器的操作指南可以查看这里。 官网提到，上证书和续签的过程都是使用Certbot来进行的。由于服务器使用的是CentOS 7，所以直接运行以下命令即可完成安装。 12$ sudo yum install epel-release$ sudo yum install certbot 其中第一个命令是安装EPEL源，也称为“企业版Linux的额外软件包（Extra Packages for Enterprise Linux）”。EPEL源了提供许多在CentOS自带源上没有的软件，而这次用到的certbot就是从EPEL源中获取的。而第二个命令则是安装certbot本身。 Certbot的官网提到，CentOS 7并不支持证书的自动安装，所以我们使用手动方式安装证书。获取证书使用certonly命令。具体参数如下： 1certbot certonly --webroot -w &lt;网页路径&gt; -d &lt;域名&gt; --webroot参数适用于使用Web服务器(如Nginx、Apache等)的网站。关于这个参数的具体使用说明可以查看这里。 -w参数后面接的是服务器请求数据的目录(“web root”)。一条命令后面可以接多个-w参数。 -d参数后面接这个目录的域名(“domain”)。同样地，一条命令后面也可以接多个-d参数。 一个简单的示例如下： 1$ certbot certonly --webroot -w /var/www/example -d example.com -d www.example.com -w /var/www/thing -d thing.is -d m.thing.is 这条命令将生成单个证书颁发给 example.com , www.example.com , thing.is 和 m.thing.is ，而域名目录分别为 /var/www/example 和 /var/www/thing 。 注意：--webroot参数的原理是在指定的web root位置（由-w指定）生成一个临时文件.well-known/acme-challenge，接着由Let’s Encrypt服务器向指定的域名（由-d指定）发起一个HTTP请求，验证DNS服务器是否能正确解析到该目录，从而验证域名的真实性。所以请在使用--webroot参数之前检查以下项目是否正常： 保证Web服务器能够请求到隐藏目录（如.well-known这样目录名前带“点”的目录）里面的内容（如.well-known/acme-challenge）。 保持80端口正常访问。 当网站使用的是国内DNS时，如DNSPOD、阿里云DNS、CloudXNS等，有几率出现DNS query timed out问题导致证书获取不成功。这时候重新执行一遍命令即可。 键入命令回车后，进入Certbot的UI界面。 首先会提示键入用于找回私钥的邮箱，回车继续： 接着，需要同意协定用来注册ACME服务： 接着便是短暂的安装过程： 唔，安装快要结束时竟然报出了UnicodeEncodeError : 由于python的默认编码是ascii，而当目标字符的编码不是ascii的时候，python会尝试使用解码器（’ascii’ codec）将其转换为ascii编码再继续执行。当程序中出现非unicode的编码的时候，由于解码器并不能转换非unicode的编码，于是就会报这样的异常。 于是手动设置环境变量更改系统的编码，命令如下： 1$ export LANG=en_US.UTF-8 接着重新使用certonly命令重新获取证书： 1certbot certonly --webroot -w &lt;网页路径&gt; -d &lt;域名&gt; 问题解决，成功获取证书： 接下来是证书的装载。这点和一般SSL证书的装载操作大致相同，不同点在于使用Let’s Encrypt并不需要手动上传证书，仅需要把证书路径指向它给出的路径即可。 Let’s Encrypt的证书位置 最新的证书默认存放在/etc/letsencrypt/live/{域名}中。当使用renew命令续签证书时，该目录下的证书总是最新的。该目录存在以下文件： privkey.pem 私钥文件 fullchain.pem 证书文件（包含证书链） cert.pem本站点的证书文件及chain.pem证书链文件（这两个文件需搭配使用） 证书归档在/etc/letsencrypt/archive/{域名}中。所有证书的改动都会归档在这里。文件名后面的序号表示文件的版本。 为了将来方便续签，我们把证书路径定在/etc/letsencrypt/live/{域名}下。 Nginx的配置示例如下：123456789101112131415161718192021222324server{ listen 80; server_name localhost; rewrite ^(.*)$ https://$host$uri permanent;}server { listen 443 ssl; server_name localhost; ssl on; ssl_certificate /etc/letsencrypt/live/{域名}/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/{域名}/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv3 TLSv1; ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; ssl_prefer_server_ciphers on; location / { root html; index index.html index.htm; }}使用这样的配置，可以将用户对http（80端口）的请求通过rewrite全部重定向至https（443端口），以实现全站https。（经测试这种设置并不会影响Let’s Encrypt验证服务器的HTTP请求。） 更改好后保存文件并重启nginx服务： 1$ nginx -s reload 大功告成。接下来放心大胆地开启HTTPS之旅吧！！！ 等等，聪明的你可能发现了，为什么证书有效期那么短呢？ 没关系，虽然证书的有效期短，可是简单一条命令即可搞定续签： 1$ certbot renew 怎么回事？原来，为了保证续签系统的效率，还没到期的证书是不会允许进行续签操作的。那么如果我想测试续签操作到底能不能正常运行该怎么办？可以使用--dry-run参数进行模拟运行： 1$ certbot renew --dry-run 注意：续签过程和前面申请的过程一样，都需要HTTP验证域名的真实性。所以请保持80端口的畅通。 当成功完成模拟运行时，我们就可以把真实的续签命令写进系统计划了。这里我使用crontab来进行任务计划。关于crontab的配置可以看这里。网上也有一个在线Cron表达式生成器，可以预览任务执行的时机，个人感觉也非常有用。 使用vim命令打开cron的任务计划表crontab： 1$ vim /etc/crontab 按i进入编辑模式，输入任务计划后，输入:wq保存并退出vim： 10 0 0/12 1/1 * ? root certbot renew --quiet 其中--quiet参数表示静默运行。 注意：官方建议计划任务的运行周期为每天两次，以保证证书能够随时更新。","link":"/zh-CN/letsencrypt-on-centos7.html"},{"title":"php造车轮：基于单主页+GET请求的模块化框架","text":"上个学期修了一门软件工程课，我们小组的project是开发一个使用PHP的管理系统。只会 echo ‘Hello World’ 的我只好赶紧从校图书馆借了一本书《PHP 5 高级应用开发实践》来好好补充知识。书中提到了一个很有趣的模块化框架，实现起来也非常简单，用来新手入门练练手对网页结构的了解也是非常有益的。在这里把它分享出来给大家，也顺便回顾一下学到的知识。在介绍框架之前，需要了解GET请求是什么。 GET请求在用户与服务器之间进行请求-响应时，两种最常被用到的方法分别为：GET和POST。 其中，GET请求的查询字符串是直接写在URL中进行发送的：1https://www.kavel.cn/?page=pdf在这段URL中，?表示GET请求的开头，而page=pdf则是查询的键值对。 而GET请求也有如下的一些原则： GET 请求可被缓存 GET 请求可保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 在PHP中，我们使用$value=$_GET[$key]方法来获取GET的内容。其中$key为我们自己定义的等号左边的内容（如page），称为键。而$value的内容即为我们需要获取的等号右边的内容（如pdf），称为值。 而这套框架的核心原理，则是利用了GET传递请求的可保留性，在单个页面（如index.php）通过GET请求获取到用户传来的不同的值 ，并根据值插入不同的模块页展现给用户。这是一种非常容易实现的模块化方案。 话不多说，赶紧进入实战环节。 获取用户传来的GET信息：123456789101112131415161718/*File name: index.php*///获取插入的子页面名称if (isset($_GET['page'])) { $p = sterilizeInput($_GET['page']);} elseif (isset($_POST['page'])) { $p = $_POST['page'];} else { $p = 'index';}//任何GET表单在赋值前必须使用消毒函数function sterilizeInput($data) { $data = trim($data); //移除字符串两侧的空白字符 $data = stripslashes($data); //移除字符串中的所有反斜杠 $data = htmlspecialchars($data); //将预定义的字符转换为 HTML 实体，可过滤单引号、双引号等 return $data;} 我们应当提防用户能够通过GET请求上传恶意代码使得对网页进行的任意操作成为可能。所以在进行赋值前，使用消毒函数对值进行消毒非常重要。 根据GET信息选择要插入的模块页面12345678910111213141516171819202122232425/*File name: index.php*///选择插入的子页面switch ($p) { case 'index': $page = 'welcome.php'; $page_title = '主页'; break; case 'pdf': $page='pdf.php'; $page_title='课堂笔记'; break; case 'resume': $page='resume.html'; $page_title='简历'; break; case '404': header(\"HTTP/1.0 404 Not Found\"); exit(); break; default: header(\"HTTP/1.0 404 Not Found\"); exit(); break;} 在这里，我们通过switch-case方式对得到的值进行判断，得到对应的页面文件名称。还要记得如果值对所有条件都不符合时，跳转到404页面。 插入模块页面1234567891011121314151617/*File name: index.php*///确保子页面存在if (!file_exists('./modules/' . $page)) { header(\"HTTP/1.0 404 Not Found\"); exit();}//插入页眉文件include_once('./includes/' . 'header.inc.html');//插入子页面include('./modules/' . $page);//插入页脚文件include_once('./includes/' . 'footer.inc.html'); 使用include($page)函数进行页面的插入。在插入页面前，还需要判断该页面是否真实存在。如果不存在，记得跳转到404页面。 为了实现模块化，我将整个页面分成三部分，分别为页眉、正文和页脚。页眉负责页面的头文件、CSS等。通过插入相同的页眉文件，我们可以确保整个网站都能得到统一的风格。 使用模块化的框架可以极大地方便模板页的开发。因为这样直接省去了编写每个页面都相同且必须的头文件和CSS等项，直接从&lt;body&gt;部分开始下笔。 我在这里则更加极端（lǎn），模板页只负责一个&lt;div&gt;，其余内容都在页眉和页脚文件中。 这里是当page=index时，网页的组成内容：12345678910/*File name: header.inc.html*/&lt;?php if (!isset($page_title)) $page_title='主页';?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;title&gt;&lt;?=$page_title?&gt; - kavel.cn&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"container body-content\"&gt;在页眉文件里，&lt;title&gt;标签里面的值$page_title由index.php定义。使用这种模块化方式的好处之一，就是在index.php内定义的变量，可以当作全局变量，在所有模块页面都能任意使用。 1234567891011/*File name: welcome.php*/function randomSplash(){...}&lt;div class=\"jumbotron\"&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;&lt;?=randomSplash()?&gt;&lt;/h1&gt; &lt;p&gt;这里是嘉维小站，我是王嘉维。&lt;/p&gt; &lt;p&gt;&lt;a class=\"btn btn-primary btn-lg\" href=\"/blog\" role=\"button\"&gt;进入博客&lt;/a&gt;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 可以看到在模块页面内只包含一个&lt;div&gt;。这极大地方便了模块页的开发，也不需要担心样式问题。 123456789/*File name: footer.inc.html*/ &lt;/div&gt; &lt;footer class=\"container body-content\"&gt; &lt;hr /&gt; &lt;p&gt;&amp;copy; &lt;?=date(\"Y\",time())?&gt; Jiawei W.&lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 页尾文件则是包含各种结束标签。当然&lt;footer&gt;标签也存在于这里。 本站首页就是使用这种框架写成的，如果感兴趣的话可以点击链接参观： https://www.kavel.cn/ 为了把博客置顶，已经删除了这个页面了 –2018-08-03","link":"/zh-CN/php-framework-using-singleton-with-GET.html"},{"title":"URLConnection自动登录深大CAS认证平台：提交表单实现方案","text":"本次实验使用HttpsURLConnection实现深大统一身份认证平台的自动登录。使用这个工具可以对包括Blackboard、OA、图书馆、财务查询、缴纳学费、公文通、校务信箱、故障报修、研究生选课和场馆订票等一切需要使用深大统一认证平台的站点实现一键登录甚至免登录的功能。 CAS验证基本原理深大统一身份认证平台使用了Jasig Central Authentication Service 3.5.2.1这个 CAS 平台。CAS，全称 Central Authentication Service，是一种比较不错的的单点登录服务框架。使用像 CAS 这样单点登录（Single Sign On, 简称 SSO）方案时，用户只需要登录一次即可访问所有相互信任的系统（比如深大内的各种站点）。 CAS的基本验证原理如图所示： 通过原理图可知，浏览器访问一个使用了 CAS 服务的页面（CAS Client，如BlackBoard）后，将会被重定向至 CAS 验证页面（CAS Server，如深大的统一身份认证平台）进行用户认证。当用户验证成功后，浏览器将获得一条唯一且不可伪造的 Ticket。然后 CAS Server 页面将浏览器重定向回 CAS Client 页面，浏览器紧接提交获得的Ticket给 Client页面，Client 页面接收到Ticket后，从后台验证该Ticket的合法性。验证通过后将自动跳转到登录后的页面，并返回相关的身份信息。 实现结果请求 BlackBoard 校园卡用户页面http://elearning.szu.edu.cn/webapps/cbb-sdgxtyM-BBLEARN/checksession.jsp，成功打印登录后的 BlackBoard 页面内容： 实现代码实现有两部分代码组成。第一个是主逻辑代码HTTPSPoster.java: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247package cn.kavel.httpsposter;import javax.net.ssl.HttpsURLConnection;import javax.net.ssl.SSLContext;import javax.net.ssl.SSLSocketFactory;import javax.net.ssl.TrustManager;import java.io.*;import java.net.*;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Created by wjw_w on 2017/4/13. */public class HTTPSPoster { private URL mHttpsURLHost; private StringBuilder mPOSTQuery; private StringBuilder mCOOKIEChain; private String action; private String cookie; private String username; private String password; /** * 构造方法 * * @param host 需要登录的目标地址 * @param username 登录用户名 * @param password 登录密码 */ HTTPSPoster(String host, String username, String password) { try { this.username = username; this.password = password; mHttpsURLHost = new URL(host); mPOSTQuery = new StringBuilder(); mCOOKIEChain = new StringBuilder(); } catch (MalformedURLException e) { e.printStackTrace(); } } /** * 添加POST请求键值对 * * @param key POST键 * @param value POST值 */ private void addPOSTQuery(String key, String value) { mPOSTQuery.append(\"&amp;\"); try { mPOSTQuery.append(URLEncoder.encode(key, \"UTF-8\")); mPOSTQuery.append(\"=\"); mPOSTQuery.append(URLEncoder.encode(value, \"UTF-8\")); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } } /** * 为302跳转请求添加Cookie链条 * * @param cookie 该次跳转返回的响应头文件内的Set-Cookie值 */ private void addCookieChain(String cookie) { if (mCOOKIEChain.toString().isEmpty()) mCOOKIEChain.append(cookie); else mCOOKIEChain.append(\";\" + cookie); System.out.println(mCOOKIEChain.toString()); } /** * 处理网页并打印最终网页的结果 * * @param connection 需要处理的URLConnection * @return 返回String类型的网页内容 * @throws IOException 连接出错时抛出该异常 */ private String getHTML(URLConnection connection) throws IOException { if (connection instanceof HttpsURLConnection) { HttpsURLConnection httpsURLConnection = (HttpsURLConnection) connection; httpsURLConnection.setSSLSocketFactory(initCustomizedSSLSocketFactory()); } connection = handleRedirect(connection); String cookies = connection.getHeaderField(\"Set-Cookie\"); cookie = cookies; BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream(), \"GBK\")); StringBuilder sb = new StringBuilder(); String s; while ((s = br.readLine()) != null) { sb.append(s); System.out.println(s); } return sb.toString(); } /** * 递归处理跳转请求 * * @param connection 当前请求 * @return 返回最终状态码不为302的请求 * @throws IOException 连接出错时抛出该异常 */ private URLConnection handleRedirect(URLConnection connection) throws IOException { System.out.println(\"respond:\" + ((HttpURLConnection) connection).getResponseCode()); for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : connection.getHeaderFields().entrySet()) { System.out.println(\"Key : \" + entry.getKey() + \" ,Value : \" + entry.getValue()); } if (((HttpURLConnection) connection).getResponseCode() == HttpURLConnection.HTTP_MOVED_TEMP) { String cookies = connection.getHeaderField(\"Set-Cookie\"); String location = connection.getHeaderField(\"Location\"); connection = new URL(location).openConnection(); if (connection instanceof HttpsURLConnection) { HttpsURLConnection httpsURLConnection = (HttpsURLConnection) connection; httpsURLConnection.setSSLSocketFactory(initCustomizedSSLSocketFactory()); } addCookieChain(cookies); connection.setRequestProperty(\"Cookie\", mCOOKIEChain.toString()); connection = handleRedirect(connection); } mHttpsURLHost = connection.getURL(); return connection; } /** * 分析登录验证页面上的元素，获取到表单提交地址和隐藏元素 * * @param HTTP String类型的网页 * @return 返回表单提交地址 */ private String analyseAuthPage(String HTTP) { String HIDDEN_REG = \"&lt;input type=\\\"hidden\\\" (.*?)/&gt;\"; String FORM_REG = \"&lt;form (.*?)/&gt;\"; List&lt;String&gt; hiddenList = getTag(HTTP, HIDDEN_REG); for (String tag : hiddenList) { String[] splited = tag.split(\"\\\"\"); String name = splited[3]; String value = splited[5]; addPOSTQuery(name, value); //添加隐藏键值对到mPOSTQuery中 } String formtag = getTag(HTTP, FORM_REG).get(0); String[] splited = formtag.split(\"\\\"\"); return \"https://\" + mHttpsURLHost.getHost() + splited[3]; } /** * 根据正则表达式匹配内容 * * @param HTML 待匹配文本内容 * @param regex 正则表达式 * @return 返回存放有匹配内容的列表 */ private List&lt;String&gt; getTag(String HTML, String regex) { Matcher matcher = Pattern.compile(regex).matcher(HTML); List&lt;String&gt; list = new ArrayList&lt;&gt;(); while (matcher.find()) { list.add(matcher.group()); } return list; } /** * 主要逻辑 * * STEP1: 裸GET传入的网页，会因为没有身份验证信息“ticket”而被跳转到CAS页面进行身份验证。 * 跳转到实际的CAS页面后，分析页面中的HTML元素，从而获取到提交表单所需要的必要信息。（包括POST地址和hidden属性的值） * 还有从响应头中获取表示当前身份的Cookie（Cookie非常重要，前几个小时因为没有正确存入Cookie而遭遇了循环跳转CAS页面） * * STEP2: 获取到必要信息后，open一个connection并将必要信息进行组装，最后加入username与password，进行POST操作。 * 在这些信息中，组装正确的Cookie值非常重要。前几个小时的实验因为没有存入正确的Cookie而被判断没有登录，一直被重定向回CAS页面。 * * STEP3: 如果一切正常，connection将会非常舒服地通过验证并跳转到所希望的页面上去。 */ private void post() { try { System.out.println(\"STEP1\"); //STEP1: GET and Analyse CAS Page (in order to get HIDDEN INFORMATION and COOKIE) String http = getHTML(mHttpsURLHost.openConnection()); String action = analyseAuthPage(http); System.out.println(\"STEP2\"); //STEP2: POST data and HIDDEN INFORMATION and COOKIE URL newPOST = new URL(action); HttpsURLConnection newPOSTConnection = (HttpsURLConnection) newPOST.openConnection(); newPOSTConnection.setSSLSocketFactory(initCustomizedSSLSocketFactory()); newPOSTConnection.setDoOutput(true); newPOSTConnection.setRequestMethod(\"POST\"); newPOSTConnection.setRequestProperty(\"Cookie\", cookie); addPOSTQuery(\"username\", username); addPOSTQuery(\"password\", password); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(newPOSTConnection.getOutputStream())); bufferedWriter.write(mPOSTQuery.toString()); bufferedWriter.flush(); System.out.println(\"STEP3\"); //STEP3: GET RESULT getHTML(newPOSTConnection); } catch (IOException e) { e.printStackTrace(); } } /** * 组装自定义SSLSocket工厂 * 在默认的情况下建立HTTPS链接时，HttpsURLConnection会根据默认的设定先去验证服务器的证书信息。 * 而由于一些未知的原因，客户端获取不到深大CAS页面的证书信息， * 于是转向客户端TrustStore中寻找证书。而默认TrustStore是空的，因为没有手工添加过证书。 * 所以这种情况下进行连接将会抛出SSLHandshakeException异常。 * 所以需要传入一个自定义的SSLSocketFactory用于绕过证书验证。 * 这个自定义的SSLSocket被传入一个假TrustManager，这个manager遇到证书验证失败不会有任何警报。当然，这种做法非常危险。 * * @return 返回自定义的SSLSocketFactory */ private SSLSocketFactory initCustomizedSSLSocketFactory() { try { TrustManager[] trustManagers = {new MyX509TrustManager()}; SSLContext sslContext = SSLContext.getInstance(\"SSL\", \"SunJSSE\"); sslContext.init(null, trustManagers, new java.security.SecureRandom()); return sslContext.getSocketFactory(); } catch (Exception e) { e.printStackTrace(); } return null; } public static void main(String[] args) { // write your code here String bb = \"http://elearning.szu.edu.cn/webapps/cbb-sdgxtyM-BBLEARN/checksession.jsp\"; String username = \"\"; String password = \"\"; HTTPSPoster poster = new HTTPSPoster(bb, username, password); poster.post(); }} 第二个是用于绕过证书验证的自定义TrustMamagerMyX509TrustManager.java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package cn.kavel.httpsposter;import javax.net.ssl.TrustManager;import javax.net.ssl.TrustManagerFactory;import javax.net.ssl.X509TrustManager;import java.security.KeyStore;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;/** * Created by wjw_w on 2017/4/13. */public class MyX509TrustManager implements X509TrustManager { /* * The default X509TrustManager returned by SunX509. We'll delegate * decisions to it, and fall back to the logic in this class if the * default X509TrustManager doesn't trust it. */ X509TrustManager sunJSSEX509TrustManager; MyX509TrustManager() throws Exception { // create a \"default\" JSSE X509TrustManager. KeyStore ks = KeyStore.getInstance(\"JKS\"); //不需要load，因为这个是假的，是特技 //ks.load(new FileInputStream(\"trustedCerts\"), // \"passphrase\".toCharArray()); TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\", \"SunJSSE\"); tmf.init(ks); TrustManager tms[] = tmf.getTrustManagers(); /* * Iterate over the returned trustmanagers, look * for an instance of X509TrustManager. If found, * use that as our \"default\" trust manager. */ for (int i = 0; i &lt; tms.length; i++) { if (tms[i] instanceof X509TrustManager) { sunJSSEX509TrustManager = (X509TrustManager) tms[i]; return; } } /* * Find some other way to initialize, or else we have to fail the * constructor. */ throw new Exception(\"Couldn't initialize\"); } /* * Delegate to the default trust manager. */ public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException { try { sunJSSEX509TrustManager.checkClientTrusted(chain, authType); } catch (CertificateException excep) { // do any special handling here, or rethrow exception. } } /* * Delegate to the default trust manager. */ public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException { try { sunJSSEX509TrustManager.checkServerTrusted(chain, authType); } catch (CertificateException excep) { /* * Possibly pop up a dialog box asking whether to trust the * cert chain. */ } } /* * Merely pass this through. */ public X509Certificate[] getAcceptedIssuers() { return sunJSSEX509TrustManager.getAcceptedIssuers(); }}","link":"/zh-CN/post-via-cas.html"},{"title":"Xcr3tChat: 一个比较安全的聊天工具","text":"最近准备换机器，在整理硬盘的时候翻出来了一套加密聊天系统的源代码，是大三的时候的大作业。这套系统使用一次性密钥对来进行端对端的聊天加密，希望能给大家在加密传输方面带来一些新的思路。完整代码在这里：https://github.com/KavelCortex/Xcr3TChat-server Xcr3tChat的特点全程RSA加密无论是对服务器进行身份校验，还是端对端进行聊天，所有内容都将使用非对称加密方式进行加密后传输。就算被中间人攻击，获取到的不过是一串184个字符的BASE64编码，在没有获取到接收端私钥的情况下根本无从破译。 对于发送聊天信息的客户端，每次发送消息前将向对方发送一个握手包请求对方发送公钥。将聊天内容使用公钥加密后直接传送至对方客户端。而接收端在每次收到握手请求后将生成一组新的密钥对。密钥对使用一次后将被销毁，即使有一条截获的消息被破解，那么对于其他消息还能保持加密。 端对端通信客户端对于服务器的通信也是使用RSA加密的方式进行。服务器使用的是固定密钥对，所以整套系统安全性的突破口在于服务器密钥的保管。由于服务器端是整套系统安全性最低的部分，所以服务器承担的工作是最不敏感的，仅为验证身份信息以及承担寻呼的任务，除此以外完全不干涉客户端之间的通信。 项目功能概述 全程加密通讯 服务器通信相关操作（如注册用户、登入登出操作等） 客户端通信相关操作（如聊天、交换公钥等） 用于跨平台通信的通信协议 用于快速开发的客户端适配器 实现方法全程加密通讯客户端与服务器端在发送数据时都需要获取对方的公钥，然后通过加密类CyptorUtil进行加密操作再进行发送。 发送方处理流程 原始数据-&gt;RSA加密-&gt;BASE64编码-&gt;发送 接收端处理流程 接收-&gt;BASE64解码-&gt;RSA 解密-&gt;原始数据 代码实现加密工具类 CryptorUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class CryptorUtil { public static String getSaltedMD5(String src, byte salt) { try { MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.update(src.getBytes()); byte[] md5 = md.digest(); md5[0] = salt; return new BigInteger(1, md5).toString(16); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); return null; } } public static String getRandomSaltedMD5(String src) { byte salt = (byte) Math.abs(new SecureRandom().nextInt(256)); src += salt; return getSaltedMD5(src, salt); } public static boolean equalsSaltedMD5(String src, String md5) { //byte salt = md5.getBytes()[0]; String saltHex = md5.substring(0, 2); byte salt = (byte) Integer.parseInt(saltHex, 16); String srcMD5 = getSaltedMD5(src + salt, salt); return srcMD5.equals(md5); } public static String encryptBASE64(byte[] data) throws IOException { return (new BASE64Encoder()).encodeBuffer(data); } public static byte[] decryptBASE64(String data) throws IOException { return (new BASE64Decoder()).decodeBuffer(data); } public static String pack(String BASE64PubKey, String rawData) throws IOException { byte[] encryptedData = cryptData(BASE64PubKey, rawData.getBytes(), Cipher.ENCRYPT_MODE); return encryptBASE64(encryptedData); } public static String unpack(String BASE64PriKey, String BASE64Data) throws IOException { byte[] data = decryptBASE64(BASE64Data); byte[] decryptedData = cryptData(BASE64PriKey, data, Cipher .DECRYPT_MODE); return new String(decryptedData, \"UTF-8\"); } public static byte[] cryptData(String BASE64Key, byte[] data, int cryptMode) { try { KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\"); KeySpec keySpec; Key key; switch (cryptMode) { case Cipher.ENCRYPT_MODE: keySpec = new X509EncodedKeySpec(decryptBASE64(BASE64Key)); key = keyFactory.generatePublic(keySpec); break; case Cipher.DECRYPT_MODE: keySpec = new PKCS8EncodedKeySpec(decryptBASE64(BASE64Key)); key = keyFactory.generatePrivate(keySpec); break; default: return null; } Cipher cipher = Cipher.getInstance(\"RSA\"); cipher.init(cryptMode, key); return cipher.doFinal(data); } catch (Exception e) { throw new IllegalStateException(\"Crypt Failed\"); } }} 服务器通信相关操作客户端开启一个socket连接至ServerSocket，通过自定义通信协议发送加密信息。服务器接收到信息后解密并解析指令，进行相应的操作并发送返回的加密信息给客户端。 功能截图注册用户 登录操作 查找并连接用户 登出操作 代码实现服务器端生成类Xcr3TServer.java1234567891011121314151617181920212223242526272829public class Xcr3TServer{ private int mPort; protected static Connection dbConn; protected final static String databaseURL=\"jdbc:mariadb://example.com:3300/xcr3tdb?user=xcr3tserver&amp;password=**********\"; protected final static String SERVER_PRIVATE_KEY = \"MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAJQLwdmayTZ90cFhNq5y6qRI3YR5\\n\" + \"4pSZyeqs8yD1FfGvdBpjzHCx4/rbl4xLvSt+BrP/QuYAd6ebqu8qRaUYTUzd2vpHA5NeU0BsRbRz\\n\" + \"V+l8ypj113o83DmOfsnGMitVqSxw754NNGxGrU5f0sdb6qSzCO3ZGRIij19+9Mv3qfdJAgMBAAEC\\n\" + \"gYAfC4QgDKxrJ+FHiwo7dM+tmbYSJLkV7lYARzpIy/xJDUDsk8b4TuV+4nOaMPu/VhMzxbCSqMBu\\n\" + \"vl8O/i9SmpEC3pOHoa2fYX1OZwUWa89VuiumDMftwIFjnRIzhQf++7GKMcVzRVSSuHlcIG7AcG34\\n\" + \"u5Gg8XtrI/vHOpornERZMQJBANIyT6h6lZzKiVy7DDuYowEU1A7LG3Ers7vt4W19VAdjGr+xO792\\n\" + \"Svv+2DdaiDWPM1P4dG6d+Wmr6JLqw9kS/QUCQQC0Tmlc2WfgLrCI8pdclB+nXcSYs2UHILcHOtr8\\n\" + \"c94SySw2XRTkJTbvqkvgjPHEYvvp8gu3Ls3/yXTUIeiOW0R1AkAhgoPQiDpx1JgxgGBi3+KcuYVV\\n\" + \"Fmw5jo4I19OocOKEivgot0ifLWym3+n4aSZt43Z7XJCzUdwBTLa3NVYjtTNBAkA3M/6cN8/O2lyg\\n\" + \"QS3IYW1jj5jea6ZVzVVcOE/NlSf7tm374vm/dAlizU/X2y82QlwAX2Po3MKjOqmzPQJ3e0f1AkEA\\n\" + \"rQNV91xRhLOKQ3uSfzrAjSv3+mg5vQ3B4VG+hoNmoVmh9V/PJcP2pAv3Zx6yCZCjhv4RuWQSFDro\\n\" + \"PEvmPCQgPQ==\"; public Xcr3TServer(int port){ System.out.println(\"Initializing Xcr3TServer...\"); mPort=port; try { dbConn = DriverManager.getConnection(Xcr3TServer.databaseURL); } catch (SQLException e) { e.printStackTrace(); } new Thread(new ServerSocketRunnable(mPort)).start(); }} 服务器操作类 SocketHandler.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319public class SocketHandler implements Runnable { private static ConcurrentHashMap&lt;UUID, Socket&gt; clientSocketList = new ConcurrentHashMap&lt;&gt;(); private UUID mUUID; private List&lt;Socket&gt; mSockets = new ArrayList&lt;&gt;(); SocketHandler(List&lt;Socket&gt; sockets) { mSockets = sockets; } public static Socket getClientSocket(UUID clientUUID) { return clientSocketList.get(clientUUID); } static int getClientServingCount() { if (clientSocketList != null) return clientSocketList.size(); else return 0; } int getSocketCount() { return mSockets.size(); } public UUID getUUID() { return mUUID; } @Override public void run() { for (Socket socket : mSockets) { try { try { mUUID = UUID.randomUUID(); clientSocketList.put(mUUID, socket); System.out.println(\"\\nADD:\" + getUUID() + \"/ \" + getClientServingCount() + \" serving\"); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; StringBuilder identity = new StringBuilder(); //Identity while ((line = bufferedReader.readLine()) != null) { identity.append(line); identity.append(\"\\r\\n\"); if (line.isEmpty()) break; } RequestParser requestParser; requestParser = new RequestParser(identity.toString()); boolean doneFlag = false; JSONObject clientJSON = requestParser.getJSON(); if (!doneFlag &amp;&amp; requestParser.isProtocolHeader (Xcr3TProtocol.REQUEST_ADD)) { try { System.out.println(clientJSON.toString()); String uid = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"uid\")); String pswMD5 = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"identity\")); //TODO: 添加用户资料进数据库 Statement statement = Xcr3TServer.dbConn .createStatement(); ResultSet rs = statement.executeQuery(\"SELECT * \" + \"FROM ClientInfo WHERE `uid`='\" + uid + \"';\"); if (rs.next()) throw new IllegalStateException(\"username is \" + \"already exist\"); int affected = statement.executeUpdate(\"INSERT \" + \"INTO ClientInfo (uid,identity,status) \" + \"values('\" + uid + \"','\" + pswMD5 + \"',\" + \"'OFFLINE');\"); if (affected == 0) throw new IllegalStateException(\"Cannot add \" + \"user.\"); rs = statement.executeQuery(\"SELECT * FROM \" + \"ClientInfo WHERE `uid`='\" + uid + \"' AND\" + \" `identity`='\" + pswMD5 + \"';\"); if (!rs.next()) throw new IllegalStateException(\"Cannot read \" + \"user.\"); Response response = new Response.Builder (Xcr3TProtocol.RESPONSE_200_OK) .setDestinationPublicKey(clientJSON .getString(\"publicKey\")) .put(\"status\", \"OK\") .put(\"id\", rs.getString(\"id\")) .put(\"uid\", rs.getString(\"uid\")) .build(); doneFlag = sendResponse(socket, response); } catch (JSONException e) { throw new IllegalStateException(\"JSON Error\"); } catch (SQLException e) { e.printStackTrace(); throw new IllegalStateException(\"SQL Server \" + \"Unavailable\"); } } if (!doneFlag &amp;&amp; requestParser.isProtocolHeader (Xcr3TProtocol.REQUEST_HANDSHAKE)) { try { System.out.println(clientJSON.toString()); String uid = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"uid\")); String psw = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"identity\")); String port = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"port\")); //TODO: 查找数据库匹配身份并返回TOKEN Statement statement = Xcr3TServer.dbConn .createStatement(); String clientQueryStr = \"WHERE `uid` = '\" + uid + \"'\"; ResultSet rs = statement.executeQuery(\"SELECT * \" + \"FROM ClientInfo \" + clientQueryStr + \";\"); if (!rs.next()) throw new IllegalStateException(\"Unknown \" + \"identity\"); if (rs.getString(\"status\").equals(\"ONLINE\")) throw new IllegalStateException(\"You have \" + \"logged in. If it isn't you, please \" + \"contact the server.\"); String md5DB = rs.getString(\"identity\"); if (!CryptorUtil.equalsSaltedMD5(psw, md5DB)) throw new IllegalStateException(\"Unknown \" + \"identity\"); statement.execute(\"UPDATE ClientInfo SET \" + \"`status`='ONLINE', `token`= '\" + getUUID () + \"' \" + \", `location`= '\" + socket.getInetAddress () + \"', `port`= '\" + port + \"' \" + clientQueryStr + \";\"); Response response = new Response.Builder (Xcr3TProtocol.RESPONSE_200_OK) .setDestinationPublicKey(clientJSON .getString(\"publicKey\")) .put(\"status\", \"OK\") .put(\"token\", getUUID().toString()) .build(); doneFlag = sendResponse(socket, response); } catch (JSONException e) { throw new IllegalStateException(\"JSON Error\"); } catch (SQLException e) { e.printStackTrace(); throw new IllegalStateException(\"SQL Error\"); } } if (!doneFlag &amp;&amp; requestParser.isProtocolHeader (Xcr3TProtocol.REQUEST_FIND)) { try { System.out.println(clientJSON.toString()); String destUID = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"destUID\")); String token = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"token\")); //TODO: 服务器比较token Statement statement = Xcr3TServer.dbConn .createStatement(); ResultSet rs = statement.executeQuery(\"SELECT \" + \"`uid` FROM ClientInfo WHERE `token`='\" + token + \"';\"); if (!rs.next()) throw new IllegalStateException(\"Bad token\"); if (rs.getString(\"uid\").equals(destUID)) throw new IllegalStateException(\"Please don't\" + \" find yourself :(\"); rs = statement.executeQuery(\"SELECT * FROM \" + \"ClientInfo WHERE `uid`='\" + destUID + \"';\"); if (!rs.next()) throw new IllegalStateException(\"Invalid user\"); //TODO:服务器连接对方并获取ready值 boolean isReady; String status = rs.getString(\"status\"); if (isReady = status.equals(\"ONLINE\")) { Response response = new Response.Builder (Xcr3TProtocol.RESPONSE_200_OK) .setDestinationPublicKey(clientJSON .getString(\"publicKey\")) .put(\"status\", \"OK\") .put(\"valid\", \"true\") .put(\"ready\", String.valueOf(isReady)) .put(\"ip\", rs.getString(\"location\") .substring(1)) .put(\"port\", rs.getString(\"port\")) .build(); doneFlag = sendResponse(socket, response); } else { if (status.equals(\"OFFLINE\")) throw new IllegalStateException(destUID + \" is OFFLINE.\"); throw new IllegalStateException(destUID + \"is\" + \" UNKNOWN.\"); } } catch (JSONException e) { throw new IllegalStateException(\"JSON Error\"); } catch (SQLException e) { e.printStackTrace(); throw new IllegalStateException(\"SQL Error\"); } } if (!doneFlag &amp;&amp; requestParser.isProtocolHeader (Xcr3TProtocol.REQUEST_GOODBYE)) { try { System.out.println(clientJSON.toString()); String uid = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"uid\")); String token = CryptorUtil.unpack(Xcr3TServer .SERVER_PRIVATE_KEY, clientJSON.getString (\"token\")); String clientQueryStr = \"WHERE `uid` = '\" + uid + \"' AND `token`='\" + token + \"'\"; //TODO: 更改服务器上的用户状态 Statement statement = Xcr3TServer.dbConn .createStatement(); statement.execute(\"UPDATE ClientInfo SET \" + \"`location`= null, `port`= null, \" + \"`status`='OFFLINE', `token`= '' \" + clientQueryStr + \";\"); Response response = new Response.Builder (Xcr3TProtocol.RESPONSE_200_OK) .setDestinationPublicKey(clientJSON .getString(\"publicKey\")) .put(\"status\", \"OK\") .put(\"goodbye\", \"true\") .build(); doneFlag = sendResponse(socket, response); } catch (JSONException e) { throw new IllegalStateException(\"JSON Error\"); } catch (SQLException e) { e.printStackTrace(); throw new IllegalStateException(\"SQL Error\"); } } if (!doneFlag) { throw new IllegalStateException(\"Unsupported Function\"); } bufferedReader.close(); closeSocket(socket); } catch (IllegalStateException e) { String err = \"Received a bad/empty request: \" + e .getMessage(); Response response = new Response.Builder(Xcr3TProtocol .RESPONSE_400_BAD_REQUEST) .put(\"status\", \"error\") .put(\"error\", e.getMessage()) .build(); sendResponse(socket, response); System.out.println(err); closeSocket(socket); } } catch (IOException e) { e.printStackTrace(); } } } private boolean sendResponse(Socket socket, Response response) throws IOException { BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(response.toString()); bufferedWriter.flush(); bufferedWriter.close(); return true; } private void closeSocket(Socket socket) throws IOException { socket.close(); clientSocketList.remove(mUUID); //System.out.println(\"DEL:\" + getUUID() + \"/ \" + getClientServingCount() + \" left\"); }} 客户端通信相关操作客户端在登录后将开启一个SocketServer，并提交该SocketServer的IP和端口号给服务器记录。当有其他客户端向服务器请求与该客户端进行通信时，服务器将返回该客户端的IP和端口号。其他客户端将直接对该地址创建一个socket进行连接。 功能截图连接用户 开始聊天 关闭会话 代码实现客户端生成类 Xcr3TClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223public class Xcr3TClient { public static final String CLIENT_NAME = \"Kavel's Xcr3Tchat Client/0.1\"; public final static String SERVERNAME = \"localhost\"; public final static int SERVERPORT = 54213; private final static String SERVER_PUBLIC_KEY = \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCUC8HZmsk2fdHBYTaucuqkSN2EeeKUmcnqrPMg\\n\" + \"9RXxr3QaY8xwseP625eMS70rfgaz/0LmAHenm6rvKkWlGE1M3dr6RwOTXlNAbEW0c1fpfMqY9dd6\\n\" + \"PNw5jn7JxjIrVakscO+eDTRsRq1OX9LHW\" + \"+qkswjt2RkSIo9ffvTL96n3SQIDAQAB\"; protected static KeyPairGenerator mKeyPairGenerator; private String mUID; private String mPassword; private ServerSocket mServerSocket; private Chattable mChatter; private ChatHandler mChatHandler; private int mPort; private String mPrivateKey; //己方PrK private String mToken = \"\"; public Xcr3TClient(String uid, String psw, Chattable chatter) { mUID = uid; mPassword = psw; mChatter = chatter; try { mKeyPairGenerator = KeyPairGenerator.getInstance(\"RSA\"); mKeyPairGenerator.initialize(1024, new SecureRandom()); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } } protected static void send(Socket socket, Object request) throws IOException { System.out.println(request.toString()); BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bufferedWriter.write(request.toString()); bufferedWriter.flush(); } protected static ResponseParser parse(Socket socket, String BASE64PriKey) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; StringBuilder header = new StringBuilder(); while ((line = bufferedReader.readLine()) != null) { header.append(line); header.append(\"\\r\\n\"); if (line.isEmpty()) break; } StringBuilder msg = new StringBuilder(); while ((line = bufferedReader.readLine()) != null) { msg.append(line); msg.append(\"\\r\\n\"); if (line.isEmpty()) break; } ResponseParser parser = new ResponseParser(header.toString(), msg .toString(), BASE64PriKey); System.out.println(parser.getJSON().toString()); return parser; } public void setChatter(Chattable chatter) { mChatter = chatter; } public String getUsername() { return mUID; } public ChatHandler getChatHandler() { return mChatHandler; } private String generatePublicKey() throws IOException { KeyPair keyPair = mKeyPairGenerator.generateKeyPair(); mPrivateKey = CryptorUtil.encryptBASE64(keyPair.getPrivate() .getEncoded()); //每次生成新KeyPair后将覆盖旧PrK return CryptorUtil.encryptBASE64(keyPair.getPublic().getEncoded()); //己方PuK本地不保存，使用一次后交由GC处理 } /** * 添加当前用户 * * @return 服务器返回添加结果 * @throws IOException */ public boolean register() throws IOException { String pswMD5 = CryptorUtil.getRandomSaltedMD5(mPassword); Request request = new Request.Builder(Xcr3TProtocol.REQUEST_ADD) .setDestinationPublicKey(SERVER_PUBLIC_KEY) .put(\"uid\", mUID) .put(\"identity\", pswMD5) .putSelfPublicKey(generatePublicKey()) .build(); ResponseParser parser = sendToServerAndParse(request); if (parser.isStatusOK()) { mChatter.printLog(\"You have successfully registered as: \" + getUsername()); return true; } else { if (parser.getJSON().has(\"error\")) mChatter.printLog(parser.getJSON().getString(\"error\")); return false; } } /** * 登录操作 * * @return 服务器返回握手结果 * @throws IOException */ public boolean login() throws IOException { mServerSocket = new ServerSocket(0); mPort = mServerSocket.getLocalPort(); Request request = new Request.Builder(Xcr3TProtocol.REQUEST_HANDSHAKE) .setDestinationPublicKey(SERVER_PUBLIC_KEY) .put(\"uid\", mUID) .put(\"identity\", mPassword) .put(\"port\", \"\" + mPort) .putSelfPublicKey(generatePublicKey()) .build(); ResponseParser parser = sendToServerAndParse(request); if (parser.isStatusOK()) { mToken = parser.getJSON().getString(\"token\"); new Thread(new ChatListener(mServerSocket, mChatter, getUsername ())).start(); mChatter.printLog(\"You have logged in as: \" + getUsername()); return true; } else { if (parser.getJSON().has(\"error\")) mChatter.printLog(parser.getJSON().getString(\"error\")); return false; } } /** * 查询某用户在线状态，接通以后将使用Chattable.incoming()回调进行通知 * * @param uid 要查询的用户ID * @return 查询结果 * @throws IllegalStateException * @throws IOException */ public boolean find(String uid) throws IllegalStateException, IOException { if (mToken.isEmpty()) throw new IllegalStateException(\"Please login first!\"); Request request = new Request.Builder(Xcr3TProtocol.REQUEST_FIND) .setDestinationPublicKey(SERVER_PUBLIC_KEY) .put(\"destUID\", uid) .put(\"token\", mToken) .putSelfPublicKey(generatePublicKey()) .build(); ResponseParser parser = sendToServerAndParse(request); if (parser.isStatusERROR()) throw new IllegalStateException(parser.getJSON().getString (\"error\")); if (parser.isStatusOK() &amp;&amp; parser.getJSON().getString(\"ready\").equals (\"true\")) { String host = parser.getJSON().getString(\"ip\"); int port = Integer.parseInt(parser.getJSON().getString(\"port\")); Socket s = new Socket(host, port); new ChatHandler(s, mChatter, getUsername()); return true; } else return false; } public void logout() throws IOException { Request request = new Request.Builder(Xcr3TProtocol.REQUEST_GOODBYE) .setDestinationPublicKey(SERVER_PUBLIC_KEY) .put(\"uid\", mUID) .put(\"token\", mToken) .putSelfPublicKey(generatePublicKey()) .build(); ResponseParser parser = sendToServerAndParse(request); if (parser.isStatusOK()) { mToken = \"\"; mServerSocket.close(); mPort = 0; mChatter.printLog(\"You (\" + getUsername() + \") have logged out.\"); } } /** * 向服务器发送请求并返回结果 * * @param request 经Request类包装后的请求对象 * @return 经ResponseParser类包装后的返回结果对象 * @throws IOException */ private ResponseParser sendToServerAndParse(Request request) throws IOException { Socket socket = new Socket(SERVERNAME, SERVERPORT); send(socket, request); ResponseParser parser = parse(socket, mPrivateKey); mPrivateKey = null; //使用一次后清除该私钥 socket.close(); return parser; }} 会话操作器 ChatHandler.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199public class ChatHandler { private Socket mSocket; private Chattable mChatter; private Map&lt;String, String&gt; mPrivateKeyChain; private Map&lt;String, String&gt; mPublicKeyChain; private Stack&lt;String&gt; mKeyIDList; private String mSelfUsername; private String mOppositeUsername; private Object keyListLock = new Object(); public ChatHandler(Socket s, Chattable chatter, String selfUsername) throws IOException { mSelfUsername = selfUsername; mSocket = s; mChatter = chatter; mPrivateKeyChain = new HashMap&lt;&gt;(); mPublicKeyChain = new HashMap&lt;&gt;(); mKeyIDList = new Stack&lt;&gt;(); new Thread(new CharReceiver()).start(); sendHandshakeMsg(); } public String getSelfUsername() { return mSelfUsername; } public String getOppositeUsername() { return mOppositeUsername; } public String getLink() { return mSelfUsername + \" -&gt; \" + mOppositeUsername; } public void sendHandshakeMsg() throws IOException { String selfKeyID = UUID.randomUUID().toString(); String selfKey = generateSelfPublicKey(selfKeyID); Request request = new Request.Builder(Xcr3TProtocol.REQUEST_HANDSHAKE) .put(\"uid\", mSelfUsername) .putEncryptID(selfKeyID) .putSelfPublicKey(selfKey) .build(); Xcr3TClient.send(mSocket, request); } public void sendChat(String chat) throws IOException { //STEP1: Request key Request keyRequest = new Request.Builder(Xcr3TProtocol.REQUEST_GET_KEY) .build(); Xcr3TClient.send(mSocket, keyRequest); //STEP2: Check keyList synchronized (keyListLock) { while (mKeyIDList.empty()) { try { keyListLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } //STEP3: Send message using receivedKey String destKeyID = mKeyIDList.pop(); String destKey = mPublicKeyChain.remove(destKeyID); Request request = new Request.Builder(Xcr3TProtocol.REQUEST_CHAT) .setDestinationPublicKey(destKey) .put(\"chat\", chat) .putDecryptID(destKeyID) .build(); Xcr3TClient.send(mSocket, request); } public void disconnect() throws IOException { Request request = new Request.Builder(Xcr3TProtocol.REQUEST_GOODBYE) .build(); Xcr3TClient.send(mSocket, request); } private String generateSelfPublicKey(String keyID) throws IOException { KeyPair keyPair = Xcr3TClient.mKeyPairGenerator.generateKeyPair(); mPrivateKeyChain.put(keyID, CryptorUtil.encryptBASE64(keyPair .getPrivate().getEncoded())); return CryptorUtil.encryptBASE64(keyPair.getPublic().getEncoded()); //己方PuK本地不保存，使用一次后交由GC处理 } private class CharReceiver implements Runnable { @Override public void run() { try { while (mSocket.isConnected()) { RequestParser parser = parseChat(mSocket); JSONObject chatJSON = parser.getJSON(); //System.out.println(parser.getProtocolHeader() + \"\\r\\n\" // + chatJSON.toString()); if (!parser.isChat()) throw new IllegalStateException(\"It's not a chat\"); if (parser.isProtocolHeader(Xcr3TProtocol .REQUEST_GET_KEY)) { String selfKeyID = UUID.randomUUID().toString(); String selfKey = generateSelfPublicKey(selfKeyID); Response keyResponse = new Response.Builder (Xcr3TProtocol.RESPONSE_200_OK) .setResponseName(Xcr3TClient.CLIENT_NAME) .put(\"encryptID\", selfKeyID) .put(\"publicKey\", selfKey) .build(); Xcr3TClient.send(mSocket, keyResponse); } if (parser.isProtocolHeader(Xcr3TProtocol.REQUEST_CHAT)) { String decryptID = chatJSON.getString(\"decryptID\"); String decryptKey = mPrivateKeyChain.remove(decryptID); String chatText = CryptorUtil.unpack(decryptKey, chatJSON.getString(\"chat\")); //TODO: 输出内容 mChatter.showChat(getSelfUsername() + \" &lt;- \" + getOppositeUsername() + \": \" + chatText); } if (parser.isProtocolHeader(Xcr3TProtocol .RESPONSE_200_OK) &amp;&amp; chatJSON.has(\"publicKey\")) { String destKey = chatJSON.getString(\"publicKey\"); String destKeyID = chatJSON.getString(\"encryptID\"); synchronized (keyListLock) { mKeyIDList.push(destKeyID); mPublicKeyChain.put(destKeyID, destKey); keyListLock.notify(); } } if (parser.isProtocolHeader(Xcr3TProtocol .REQUEST_HANDSHAKE)) { mOppositeUsername = chatJSON.getString(\"uid\"); mChatter.incoming(ChatHandler.this); } if (parser.isProtocolHeader(Xcr3TProtocol .REQUEST_GOODBYE)) { Response keyResponse = new Response.Builder (Xcr3TProtocol.RESPONSE_200_OK) .setResponseName(Xcr3TClient.CLIENT_NAME) .put(\"goodbye\", \"true\") .build(); Xcr3TClient.send(mSocket, keyResponse); mChatter.disconnecting(ChatHandler.this); mSocket.close(); } if (parser.isProtocolHeader(Xcr3TProtocol .RESPONSE_200_OK) &amp;&amp; chatJSON.has(\"goodbye\")) { if (chatJSON.getString(\"goodbye\").equals(\"true\")) mChatter.disconnecting(ChatHandler.this); mSocket.close(); } } } catch (IOException e) { mChatter.printLog(\"Connection Closed: \" + getLink()); mChatter.disconnecting(ChatHandler.this); } } private RequestParser parseChat(Socket socket) throws IOException { BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; StringBuilder chatContent = new StringBuilder(); while ((line = bufferedReader.readLine()) != null) { chatContent.append(line); chatContent.append(\"\\r\\n\"); if (line.isEmpty()) break; } if (chatContent.toString().startsWith(Xcr3TProtocol .RESPONSE_200_OK)) { while ((line = bufferedReader.readLine()) != null) { chatContent.append(line); chatContent.append(\"\\r\\n\"); if (line.isEmpty()) break; } } return new RequestParser(chatContent.toString()); } }} 用于跨平台通信的通信协议为了方便后续进行跨平台通信，制定了一套 RESTful API 作为通信规范。发送方使用Request.Builder()、Response.Builder()生成符合规范的请求头，使用RequestParser、ResponseParser解析符合规范的请求。 API内容 用户操作 发送至 协议头 附加数据 对方返回数据 注册用户 服务器 POST /register HTTP/1.1 {uid,identity,publicKey} {status,uid,id} 登录 服务器 POST /handshake HTTP/1.1 {uid,identity,port,publicKey} {status,token} 寻找用户 服务器 POST /find HTTP/1.1 {destUID,token} {status,valid,ready,ip,port} [聊天]握手 对方客户端 POST /handshake HTTP/1.1 {uid,encryptID,publicKey} - [聊天]获取公钥 对方客户端 GET /key HTTP/1.1 - {encryptID,publicKey} [聊天]发送信息 对方客户端 POST /chat HTTP/1.1 {chat,decryptID} - [聊天]关闭会话 对方客户端 POST /goodbye HTTP/1.1 - - 登出 服务器 POST /goodbye HTTP/1.1 {uid,token,publicKey} {status,goodbye} 代码实现协议类 Xcr3TProtocol.java1234567891011121314public class Xcr3TProtocol { public static final String REQUEST_ADD=\"POST /register HTTP/1.1\"; public static final String REQUEST_HANDSHAKE =\"POST /handshake HTTP/1.1\"; public static final String REQUEST_GET_KEY=\"GET /key HTTP/1.1\"; public static final String REQUEST_FIND=\"POST /find HTTP/1.1\"; public static final String REQUEST_GOODBYE =\"POST /goodbye HTTP/1.1\"; public static final String REQUEST_CHAT=\"POST /chat HTTP/1.1\"; public static final String RESPONSE_200_OK=\"HTTP/1.1 200 OK\"; public static final String RESPONSE_400_BAD_REQUEST=\"HTTP/1.1 400 Bad Request\";} 请求生成类 Request.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Request { private String mProtocolHeader; private JSONObject mJSON; private Request() { } private Request(Builder builder) { mProtocolHeader = builder.mProtocolHeader; mJSON = builder.mJSON; } @Override public String toString() { StringBuilder request = new StringBuilder(); request.append(mProtocolHeader); request.append(\"\\r\\n\"); request.append(mJSON.length() &gt; 0 ? mJSON.toString() : \"\"); request.append(\"\\r\\n\\r\\n\"); return request.toString(); } public static class Builder { private String mProtocolHeader; private String mDestPublicKey; private JSONObject mJSON; private boolean needEncrypt; public Builder(String protocolHeader) { mProtocolHeader = protocolHeader; mJSON = new JSONObject(); } public Builder setDestinationPublicKey(String BASE64PubKey) { needEncrypt = true; mDestPublicKey = BASE64PubKey; return this; } public Builder put(String key, String value) throws IOException { String encryptedValue; if (needEncrypt) encryptedValue = CryptorUtil.pack(mDestPublicKey, value); else encryptedValue = value; mJSON.put(key, encryptedValue); return this; } public Builder putEncryptID(String id) { mJSON.put(\"encryptID\", id); return this; } public Builder putDecryptID(String id) { mJSON.put(\"decryptID\", id); return this; } public Builder putSelfPublicKey(String BASE64PubKey) { mJSON.put(\"publicKey\", BASE64PubKey); return this; } public Request build() { return new Request(this); } }} 回应生成类 Response.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Response { private static final String SERVER_NAME = \"Kavel's Xcr3Tchat Server/0.1\"; private String mResponseName; private String mProtocolHeader; private int mContentLength = 0; private JSONObject mJSON; private String mEncryptedResponse; private Response() { } private Response(Builder builder) { mResponseName = builder.mResponseName; mProtocolHeader = builder.mProtocolHeader; mEncryptedResponse = builder.mEncryptedResponse; mContentLength = mEncryptedResponse.length(); mJSON = builder.mJSON; } public String getServerName() { return mResponseName; } public String getProtocolHeader() { return mProtocolHeader; } public JSONObject getJSON() { return mJSON; } public int getContentLength() { return mContentLength; } @Override public String toString() { StringBuilder response = new StringBuilder(); response.append(mProtocolHeader + \"\\r\\n\"); response.append(\"Server: \" + mResponseName + \"\\r\\n\"); response.append(\"Content-Length: \" + mContentLength + \"\\r\\n\"); response.append(\"\\r\\n\"); response.append(mEncryptedResponse); response.append(\"\\r\\n\\r\\n\"); return response.toString(); } public static class Builder { private String mResponseName; private String mProtocolHeader; private String mDestPublicKey; private JSONObject mJSON; private String mEncryptedResponse; private boolean needEncrypt; public Builder(String protocolHeader) { mProtocolHeader = protocolHeader; mJSON = new JSONObject(); mResponseName = SERVER_NAME; } public Builder setResponseName(String name) { mResponseName = name; return this; } public Builder setDestinationPublicKey(String BASE64PubKey) { needEncrypt = true; mDestPublicKey = BASE64PubKey; return this; } public Builder put(String key, String value) throws IOException { mJSON.put(key, value); return this; } public Response build() throws IOException { if (needEncrypt) mEncryptedResponse = CryptorUtil.pack(mDestPublicKey, mJSON .toString()); else mEncryptedResponse = mJSON.toString(); return new Response(this); } }} 请求解析类 RequestParser.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class RequestParser { private final String mRawRequest; private String mMethod; private String mProtocolHeader; private JSONObject mJSON; private HashMap&lt;String, String&gt; mQueryMap = new HashMap&lt;&gt;(); private boolean isBadRequest; public RequestParser(String rawRequest) { mRawRequest = rawRequest; if (mRawRequest.isEmpty()) { isBadRequest = true; throw new IllegalStateException(\"Empty Request\"); } parseRequest(); } private RequestParser(String rawRequest, String method, String func) { mRawRequest = rawRequest; mMethod = method; } public String getRawRequest() { return mRawRequest; } public String getRequestMethod() { return mMethod; } public boolean isRequestMethod(String methodType) { return mMethod.equals(methodType); } public String getProtocolHeader() { return mProtocolHeader; } public boolean isProtocolHeader(String protocolHeader) { return mProtocolHeader.startsWith(protocolHeader); } public boolean isChat() { return isProtocolHeader(Xcr3TProtocol.REQUEST_CHAT) || isProtocolHeader(Xcr3TProtocol.REQUEST_HANDSHAKE) || isProtocolHeader(Xcr3TProtocol.REQUEST_GET_KEY) || isProtocolHeader(Xcr3TProtocol.REQUEST_GOODBYE) || isProtocolHeader(Xcr3TProtocol.RESPONSE_200_OK); } public JSONObject getJSON() { return mJSON; } public HashMap&lt;String, String&gt; getQueryMap() { return mQueryMap; } public String getQueryValue(String key) { return mQueryMap.get(key); } public boolean isBadRequest() { return isBadRequest; } public static RequestParser generateBadRequest() { return new RequestParser(\"\", \"\", \"/bad.request\"); } private void parseRequest() { mProtocolHeader = mRawRequest.substring(0, mRawRequest.indexOf (\"\\r\\n\")).trim(); mMethod = mProtocolHeader.substring(0, mProtocolHeader.indexOf(\"/\")) .trim(); try { if (mRawRequest.contains(\"{\")) { String jsonRaw = mRawRequest.substring(mRawRequest.indexOf (\"{\"), mRawRequest.indexOf(\"}\") + 1); mJSON = new JSONObject(jsonRaw); } } catch (Exception e) { throw new IllegalStateException(\"No JSON Found\"); } } private void fillQueryMap(String queryString) { for (String querySet : queryString.split(\"&amp;\")) { String queryKey = querySet.split(\"=\")[0]; String queryValue = \"\"; try { queryValue = querySet.split(\"=\")[1]; } catch (ArrayIndexOutOfBoundsException e) { queryValue = \"\"; } mQueryMap.put(queryKey, queryValue); } }} 回应解析类 ResponseParser.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ResponseParser { private String mHeader; private String mMsg; private JSONObject mJSON; private String mBASE64PriKey; private boolean isOK; public ResponseParser(String header, String msg, String BASE64PriKey) { mHeader = header.split(\"\\n\")[0].trim(); mMsg = msg; mBASE64PriKey = BASE64PriKey; if (mHeader.isEmpty()) throw new IllegalStateException(\"Empty Response\"); parseResponse(); } public JSONObject getJSON() { return mJSON; } public boolean isResponse(String protocolHeader) { return mHeader.equals(protocolHeader); } public boolean isResponseOK() { return isOK; } public boolean isStatusOK() { return isOK &amp;&amp; mJSON.get(\"status\").equals(\"OK\"); } public boolean isStatusERROR() { return mJSON.has(\"status\") &amp;&amp; mJSON.get(\"status\").equals(\"error\"); } private void parseResponse() { String decryptedMsg = \"\"; if (mHeader.equals(Xcr3TProtocol.RESPONSE_200_OK)) { isOK = true; try { byte[] data = CryptorUtil.cryptData(mBASE64PriKey, CryptorUtil.decryptBASE64(mMsg), Cipher.DECRYPT_MODE); decryptedMsg = new String(data, \"UTF-8\"); } catch (IOException e) { e.printStackTrace(); } } else if (mHeader.equals(Xcr3TProtocol.RESPONSE_400_BAD_REQUEST)) { isOK = false; decryptedMsg = mMsg; } mJSON = new JSONObject(decryptedMsg); }} 用于快速开发的客户端适配器为了能够进行客户端的快速开发，创建了一套Java API，通过调用相关方法即可快速开发出一个符合规范的Java客户端。 API分为三部分，分别是： Chattable接口：提供信息的回调方法。 Xcr3TClient类：客户端主类，可调用其公有方法完成上述所有用户操作。 Xcr3TAdapter类：客户端适配器类，支持多客户端、命令行操作，传入Chattable类后能够支持信息回显。 代码实现信息回调接口 Chattable.java1234567public interface Chattable { void incoming(ChatHandler handler); void disconnecting(ChatHandler handler); void showChat(String chat); void printLog(String message); void updateUI();} 客户端适配器类 Xcr3TAdapter.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337public class Xcr3TAdapter { Chattable mChatter; private Xcr3TClient mCurrentIdentity; private ChatHandler mCurrentChatHandler; private Map&lt;String, Xcr3TClient&gt; mIdentityMap = new HashMap&lt;&gt;(); private Map&lt;String, Map&lt;String, ChatHandler&gt;&gt; mChatHandlerMap = new HashMap&lt;&gt;(); private Options mCliOptions; private HelpFormatter mHelpFormatter; public Xcr3TAdapter(Chattable chatter) { mChatter = chatter; initCli(); } public Xcr3TClient getCurrentIdentity() { return mCurrentIdentity; } public ChatHandler getCurrentChatHandler() { return mCurrentChatHandler; } public Map&lt;String, Xcr3TClient&gt; getIdentityMap() { return mIdentityMap; } public Map&lt;String, ChatHandler&gt; getChatHandlerMap(String identity) { if (!mChatHandlerMap.containsKey(identity)) mChatHandlerMap.put(identity, new HashMap&lt;&gt;()); return mChatHandlerMap.get(identity); } public void login(String uid, String psw) { if (mIdentityMap.containsKey(uid)) throw new IllegalStateException(\"already logged in.\"); addIdentity(uid, psw); } public void logout() { if (mCurrentIdentity == null) throw new IllegalStateException(\"please select an identity to log\" + \" out.\"); logout(mCurrentIdentity.getUsername()); } public void logout(String identity) throws IllegalStateException { if (!mIdentityMap.containsKey(identity)) throw new IllegalStateException(\"Invalid identity\"); Xcr3TClient client = mIdentityMap.get(identity); try { rmIdentity(client); } catch (IOException e) { e.printStackTrace(); } } public void register(String uid, String psw1, String psw2) { if (!psw1.equals(psw2)) throw new IllegalStateException(\"password must be the same.\"); Xcr3TClient client = new Xcr3TClient(uid, psw2, mChatter); try { if (client.register()) addIdentity(client); } catch (IOException e) { throw new IllegalStateException(\"Couldn't connect to server.\"); } } public void switchIdentity(String identity) { if (mIdentityMap.containsKey(identity)) { setCurrentClient(identity); } else throw new IllegalStateException(\"Invalid Identity.\"); } public void connect(String uid) { try { mCurrentIdentity.find(uid); } catch (IOException e) { throw new IllegalStateException(\"Couldn't connect to server.\"); } } public void disconnect() { if (mCurrentChatHandler == null) throw new IllegalStateException(\"please select an contact to \" + \"disconnect.\"); disconnect(mCurrentChatHandler.getLink()); } public void disconnect(String link) { String identity = link.split(\"-&gt;\")[0].trim(); String contact = link.split(\"-&gt;\")[1].trim(); if (!getIdentityMap().containsKey(identity) || !getChatHandlerMap(identity).containsKey(contact)) throw new IllegalStateException(\"Invalid link\"); ChatHandler handler = getChatHandlerMap(identity).get(contact); try { handler.disconnect(); } catch (IOException e) { throw new IllegalStateException(\"Couldn't connect to server.\"); } } public void forward(String contact) { String identity = mCurrentIdentity.getUsername(); String link = identity + \" -&gt; \" + contact; if (mChatHandlerMap.containsKey(identity) &amp;&amp; mChatHandlerMap.get (identity).containsKey(contact)) { mCurrentChatHandler = mChatHandlerMap.get(identity).get(contact); setCurrentHandler(link); } else throw new IllegalStateException(\"Invalid forward\"); } public void cmd(String[] args) { try { CommandLineParser parser = new DefaultParser(); CommandLine line = parser.parse(mCliOptions, args); if (line.hasOption(\"h\")) { StringWriter sw = new StringWriter(); mHelpFormatter.printHelp(new PrintWriter(sw), 100, \"[command]\" + \" [message]\", \"\", mCliOptions, 0, 0, \"\"); mChatter.printLog(sw.toString()); } if (line.hasOption(\"l\")) { String uid = line.getOptionValues(\"l\")[0]; String psw = line.getOptionValues(\"l\")[1]; login(uid, psw); } if (line.hasOption(\"o\")) { String identity = line.getOptionValue(\"o\"); if (identity == null) logout(); else logout(identity); } if (line.hasOption(\"r\")) { String uid = line.getOptionValues(\"r\")[0]; String psw1 = line.getOptionValues(\"r\")[1]; String psw2 = line.getOptionValues(\"r\")[2]; register(uid, psw1, psw2); } if (line.hasOption(\"s\")) { String identity = line.getOptionValue(\"s\"); switchIdentity(identity); } if (line.hasOption(\"c\")) { String uid = line.getOptionValue(\"c\"); connect(uid); } if (line.hasOption(\"d\")) { String link = line.getOptionValue(\"d\"); if (link == null) disconnect(); else disconnect(link); } if (line.hasOption(\"f\")) { String contact = line.getOptionValue(\"f\"); forward(contact); } String chatText = String.join(\" \", line.getArgs()); if (chatText.isEmpty()) { mChatter.updateUI(); return; } if (mCurrentChatHandler == null) throw new IllegalStateException(\"Oops! we don't know who to \" + \"be sent to! Please select a contact!\"); if (mCurrentIdentity == null) throw new IllegalStateException(\"Hi stranger! Please log in \" + \"or select your identity!\"); mCurrentChatHandler.sendChat(chatText); mChatter.showChat(mCurrentChatHandler.getSelfUsername() + \" -&gt; \" + mCurrentChatHandler.getOppositeUsername() + \": \" + chatText); mChatter.updateUI(); } catch (ParseException e) { StringWriter sw = new StringWriter(); mHelpFormatter.printHelp(new PrintWriter(sw), 100, \"[command] \" + \"[message]\", \"\", mCliOptions, 0, 0, \"\"); mChatter.printLog(sw.toString()); } catch (IllegalStateException e) { mChatter.printLog(e.getMessage()); } catch (IOException e) { e.printStackTrace(); } } private void initCli() { mHelpFormatter = new HelpFormatter(); mCliOptions = new Options(); mCliOptions.addOption(\"h\", \"help\", false, \"print help for the command\" + \".\"); mCliOptions.addOption( Option.builder(\"l\").longOpt(\"login\") .numberOfArgs(2) .valueSeparator(' ') .argName(\"uid password\") .desc(\"login using uid and password\") .build()); mCliOptions.addOption( Option.builder(\"o\").longOpt(\"logout\") .hasArg() .optionalArg(true) .argName(\"identity\") .desc(\"logout current identity, or specified ideneity\") .build()); mCliOptions.addOption( Option.builder(\"r\").longOpt(\"register\") .numberOfArgs(3) .argName(\"uid password re-enter-password\") .desc(\"register using uid and password\") .build()); mCliOptions.addOption( Option.builder(\"s\").longOpt(\"switch\") .numberOfArgs(1) .argName(\"identity\") .desc(\"switch to available identity\") .build()); mCliOptions.addOption( Option.builder(\"c\").longOpt(\"connect\") .numberOfArgs(1) .argName(\"uid\") .desc(\"connect to a contact\") .build()); mCliOptions.addOption( Option.builder(\"d\").longOpt(\"disconnect\") .hasArg() .optionalArg(true) .argName(\"link\") .desc(\"disconnect current link, or specified link\") .build()); mCliOptions.addOption( Option.builder(\"f\").longOpt(\"forward\") .numberOfArgs(1) .argName(\"uid\") .desc(\"send chat to specified contact\") .build()); } private void addIdentity(String uid, String psw) { Xcr3TClient client = new Xcr3TClient(uid, psw, mChatter); addIdentity(client); } public void addIdentity(Xcr3TClient client) { try { if (client.login()) { mIdentityMap.put(client.getUsername(), client); mCurrentIdentity = client; mChatter.updateUI(); } } catch (IOException e) { throw new IllegalStateException(\"Cannot log Identity: \" + client .getUsername()); } } public void rmIdentity(Xcr3TClient client) throws IOException { mCurrentIdentity = client; String identity = mCurrentIdentity.getUsername(); Map&lt;String, ChatHandler&gt; handlerMap = mChatHandlerMap.get(identity); for (ChatHandler handler : handlerMap.values()) { handler.disconnect(); } handlerMap.clear(); mCurrentIdentity.logout(); mIdentityMap.remove(identity); mCurrentIdentity = null; mChatter.updateUI(); } public void addContact(ChatHandler handler) { String identity = handler.getSelfUsername(); String contact = handler.getOppositeUsername(); getChatHandlerMap(identity).put(contact, handler); mCurrentChatHandler = handler; mChatter.printLog(\"contact connected:\" + handler.getLink()); mChatter.updateUI(); } public void rmContact(ChatHandler handler) { mCurrentChatHandler = handler; String identity = mCurrentChatHandler.getSelfUsername(); String contact = mCurrentChatHandler.getOppositeUsername(); getChatHandlerMap(identity).remove(contact); mCurrentChatHandler = null; mChatter.updateUI(); } public void setCurrentClient(String identity) { if (identity != null) { if (mCurrentIdentity == null || (!identity.equals (mCurrentIdentity.getUsername()) &amp;&amp; getIdentityMap() .containsKey(identity))) { mChatter.printLog(\"switching to Identity: \" + identity); mCurrentIdentity = mIdentityMap.get(identity); mChatter.updateUI(); } } } public void setCurrentHandler(String link) { if (link != null) { String identity = link.split(\" -&gt; \")[0]; String contact = link.split(\" -&gt; \")[1]; if (!link.equals(mCurrentChatHandler.getLink()) &amp;&amp; getIdentityMap().containsKey(identity) &amp;&amp; getChatHandlerMap(identity).containsKey(contact)) { mChatter.printLog(\"switching to connection: \" + link); mCurrentChatHandler = mChatHandlerMap.get(identity).get (contact); mChatter.updateUI(); } } }} 附：快速开发示例 ChatterUIChatterUI 是一个使用 Java API 进行快速开发的示例。它通过创建Xcr3TAdapter对象对多个客户端进行管理，实现Chattable接口以实现信息回显的功能。在文本框内键入命令行进行操作。也可以鼠标点选右方的列表栏进行客户端与会话的管理操作。 代码实现ChatterUI.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135public class ChatterUI implements Chattable { private JTextField cmdField; private JPanel panel; private JButton SENDButton; private JTextPane chatPane; private JList lsIdentity; private JList lsContact; private JScrollPane scrollPane; private DefaultListModel&lt;String&gt; mListModelIdentity; private DefaultListModel&lt;String&gt; mListModelContact; private Xcr3TAdapter adapter; public ChatterUI() { adapter = new Xcr3TAdapter(this); mListModelIdentity = new DefaultListModel&lt;&gt;(); mListModelContact = new DefaultListModel&lt;&gt;(); lsIdentity.setModel(mListModelIdentity); lsContact.setModel(mListModelContact); SENDButton.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String command = cmdField.getText(); cmdField.setText(\"\"); adapter.cmd(command.split(\" \")); } }); lsIdentity.addListSelectionListener(new ListSelectionListener() { @Override public void valueChanged(ListSelectionEvent e) { if (!e.getValueIsAdjusting()) adapter.setCurrentClient((String) lsIdentity .getSelectedValue()); } }); lsContact.addListSelectionListener(new ListSelectionListener() { @Override public void valueChanged(ListSelectionEvent e) { if (!e.getValueIsAdjusting()) { adapter.setCurrentHandler((String) lsContact .getSelectedValue()); } } }); cmdField.addKeyListener(new KeyAdapter() { @Override public void keyPressed(KeyEvent e) { super.keyPressed(e); if (e.getKeyCode() == KeyEvent.VK_ENTER) SENDButton.doClick(); } }); } public static void main(String[] args) throws IllegalStateException { try { UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.nimbus\" + \".NimbusLookAndFeel\"); } catch (Exception e) { e.printStackTrace(); } JFrame frame = new JFrame(\"ChatterUI\"); frame.setContentPane(new ChatterUI().panel); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.pack(); frame.setVisible(true); } @Override public void incoming(ChatHandler handler) { adapter.addContact(handler); } @Override public void disconnecting(ChatHandler handler) { adapter.rmContact(handler); } @Override public void showChat(String chat) { Document doc = chatPane.getDocument(); try { doc.insertString(doc.getLength(), chat + \"\\r\\n\", new SimpleAttributeSet()); chatPane.setCaretPosition(doc.getLength()); } catch (BadLocationException e) { e.printStackTrace(); } } @Override public void printLog(String message) { Document doc = chatPane.getDocument(); try { doc.insertString(doc.getLength(), \"System:\" + message + \"\\r\\n\", new SimpleAttributeSet()); chatPane.setCaretPosition(doc.getLength()); } catch (BadLocationException e) { e.printStackTrace(); } } @Override public void updateUI() { mListModelIdentity.clear(); mListModelContact.clear(); for (String identity : adapter.getIdentityMap().keySet()) { mListModelIdentity.addElement(identity); for (ChatHandler handler : adapter.getChatHandlerMap(identity) .values()) { mListModelContact.addElement(handler.getLink()); } } if (adapter.getCurrentIdentity() != null) lsIdentity.setSelectedValue(adapter.getCurrentIdentity() .getUsername(), true); if (adapter.getCurrentChatHandler() != null) lsContact.setSelectedValue(adapter.getCurrentChatHandler() .getLink(), true); }} 项目总结本次实验工程量巨大，从一开始的功能制定就画了张大饼，接下来的工作就是竭尽全力去填满这张大饼。对于每个功能的流程构思，我使用了软件工程里面的开发方式，先画出各项功能的流程图，不得不说这种方式在开发一套复杂系统时能够保持思路的清晰，不至于一不小心迷失在细节的深渊当中。在构思和实现这套加密算法时，我对RSA、MD5操作、字符串转BASE64操作有了更深刻的认识。而写的这个加密类是我非常满意的一个地方。这个加密类使得复杂的加密解密过程被包装在了简单的两个方法pack()和unpack()中，使得编程效率大大的提高，这也是全局RSA加密得以实现的基础。对于跨平台开发，虽然这次项目提交的时候并没有实现一个跨平台的客户端，但是为此制定的一套RESTful API也是本次项目的一个亮点。因为通过这套API确实看到了跨平台开发的曙光。虽然这个作业提交了，但是这个项目还远远没有结束。我从中看到了一个非常大的可能性，所以并不会放弃该项目，会将持续对其进行开发。","link":"/zh-CN/xcr3tchat.html"},{"title":"SNC的复仇-全文完","text":"这是一篇于09年开始落笔、14年高考前停笔的连载短篇。其灵感来源于一款名为GTA:SA的游戏及其相关插件（联机插件SA-MP、作弊插件m0d_s0beit、功能插件CLEO）。今天猛然从硬盘的角落翻出来全套word文档，发现自己竟然在这5年间断断续续地写了35篇整，今有感而发决定把他们重新修改一番完整发出来，算是对过去一同游戏的，如今各奔东西的曾经的少年们的怀念，也是对自己愉快的童年重新回味一番罢。 出塞一个还算可以的晴天，平常得不能再平常。 在S城的银行里，来了三个不像来存钱的人，其中两个人的身后还背着一个很长的袋子。门外停着一辆改装得不像样的Turismo，车牌甚至是夸张的”SNC94110”。这三个人向银行里望了一阵，突然他们之中一个叫SBill的人突然好像想起什么似的，向口袋里的控制器按下一个键，接着迅速拿起藏在上衣里面的MP5指着柜台前的职员：“马上拿出5000万！立刻！”看见银行职员没有想拿钱的动作，SBill轻声地说了一声：“索嘎…”SBill身后的两个人听到了，也把自己的左手伸进口袋里，把脸望向SBill，像是在等待这什么信号。银行职员警觉了起来：“你们…想干什么…” SBill轻轻点了一下头，身后两个人的左手向控制器也按下一个键。只见一个人从身后的袋子里抽出一把RPG，对着柜台就是一发，整个柜台顿时穿了一个大洞。SBill大喊：“依克做！”然后也从身后的袋子里拿出另一把RPG，和那个射穿柜台的叫NCkr的人冲了进去。而那个什么都没拿的CKavel则是径直跑出去启动那台改装得不像样的Turismo。 这是一辆货车版Turismo。前半部分是普通的Turismo车身，后半部分发动机上则架起了一个木制的带围栏的载物台。从这夸张的改装来看大概是一个爱好改装的农民制作的，实用又不影响美观。这辆货车版Turismo还是前几天NCkr在LDZ比赛赢的，只可惜他不会开，就被CKavel“借”走了。正当CKavel把车子启动时，远处便开始传来警笛声。从声音上判断，有几十辆、甚至是几百辆警车正往这里开来。“氧化钙…”CKavel说道。这时，正看到SBill和NCkr拿着大袋钱跑过来。CKavel说：“来不及了，快坐上货柜！”接着一个甩尾飙出去好远。 亡命高速公路(1)当SBill和 NCkr上车后，CKavel二话不说，一踩油门将车完美的甩出了个180度，从那些警察的身边擦过。“Holyckr!我的车!”NCkr边坐稳边说道。“放心吧NC…以我的技术保证你的车没刮到那些警车…”CKavel敏捷地躲过前面开来的警车说道，“你们也别愣着，快解决掉那些警车！SB，把车上的人都干了！”“WTF…”SBill抓起一把狙击枪，以他神圣的枪法把后面追上的车一个一个解决掉。 “SHIT!”CKavel大叫道。正说着，旁边的小道突然冲出一辆N.O.O.S.E防暴车。车里面的特种兵一个个发了疯似的往Turismo的车顶跳去。“我的车顶被你糟蹋啦！”NCkr大叫道，然后也跳上车顶拼命地把他们扔下去。“WTF?!”SBill看到这个情况，左手伸出一把沙鹰，头也不回地快速把车顶上的特种兵解决了。“好了…下来吧…”SBill说道，然后继续狙杀车后的人。见后面的警车越来越多，SBill也渐渐招架不住了。等NCkr回到载物台时，CKavel一个甩尾把车上的尸体甩开，说：“NCkr你也别呆着，用RPG轰掉后面的车！”“好吧…”NCkr拿起RPG对着后面就是一阵狂轰。“氧化钙…抢我生意…”SBill说着放下枪口热得发红的狙击枪，拿起RPG朝着上空的直升飞机就是一发。 “在这里兜圈也没办法了，赶紧逃到下一个城市吧！”SBill说道。“离这里最近的是哪个城市？”“LS城离这里最近。”“好吧…”CKavel说，“也只能去那里了。” 亡命高速公路(2)在通往LS的公路上。 “WTF?!后面的警车没完没了！CK！我的火箭筒弹药快用完了！得想办法甩开他们！”SBill大叫。“来不及了…看看前面…”NCkr 说。他们正前方有两辆坦克横在公路中间，试图挡住他们的道路。“我氧化钙…我的车技可不是吹的！看我的B！”CKavel边说着，边从口袋里拿出控制器， 按下写着“B”字样的键。只见货车版Turismo立刻弹跳到空中，以优美的抛物线从离他们只有半米远的两辆坦克上空飞过，接着平稳落地。NCkr看着后面的警车一个接着一个被那两辆坦克撞炸，感慨了一句：“Holyckr…” 又走了很大段路，离LS城也已经越来越近了。可是路上连一辆警车都没有，甚至警笛声都消失了。SBill有种不祥的预感：“怎么那么平静…不会是个陷阱吧…”果然被SBill说中了。在他说了这句话没过多久，CKavel慢慢地把车停了下来。他们三个都看傻了。而前方竟然是。。。 断桥。而对面正是LS城。 极品飞车CKavel停住了车。车后的两人陆续跳下了车。在断桥的上空，盘旋着十几架警用直升机，而桥的那边也渐渐被N.O.O.S.E给占领了。NCkr拿出他那由狙击镜拼成的双筒望远镜看着越来越多的飞机群。“无路可逃了啊…话说那个飞行员长的实在看不下去啊……”“…没办法了吗…”CKavel轻叹了一口气，打开车门，从口袋里拿出最后一支POCKY咬在嘴上，然后慢慢地从车子里出来。转身从载物架里拿出一块大木板，用空的POCKY包装盒把木板架起，放在了断桥的边上。“SB，就看你的了。”CKavel转身进了副驾驶座。 只见SBill的嘴唇往上挑了挑。“NC，上车！”随后进了驾驶座。NCkr拿出绳子一头系在车顶，另一头绑在腰间，跳上了载物台。 松开手刹，只见SBill以完美的操作使车向后急退。到了一定距离后，只见SBill右手华丽的挂档、拉手刹，车轮正拉着白烟在原地拼命地空转。“准备好…3..2..1..日啊！！”车子以极高的加速度向前飞奔。前车轮快碰到木板的那一刹那，SBill按下了控制器里印着Alt字样的键。 “这里是13号机，这里是13号机。抢劫犯好像有些行动了，请大家警戒….噢不….他们准备冲向断桥的另一侧！这根本不可能！…他们飞起来了！他们违背了重力！…车顶上还有个人！他好像拿着什么东西向我扔来！……（BOOM）！”“哈！一架直升机！”NCkr手拿着手榴弹，威风的站在车顶上。“喵！”另一架直升机坠落。“你！”又一架直升机坠落。“个！”再一架直升机坠落。“咪！”第五架直升机坠落。正说着，那辆Turismo已经成功的到达了桥的对面。现在，他们的只能去当年“油炸旧金山”行动认识的一名队友那里暂时躲一下风声。他叫Chun Juan。有的叫他CJ,有的叫他春哥。他是SNC三人在LS城里唯一认识的人了。 洛圣都，新的开始“Good Job！”CKavel边往窗后射击，边称赞SBill的华丽的驾驶技术。“哼…当然…我可是当年雷达站【华丽的控车艺术】比赛的二等奖获得者…”NCkr经过刚才眼花缭乱的杂技，感觉有些累，摊在车顶吐槽道：“嘛…他那个比赛…冠军亚军季军各一名…后面是一等奖4名…二等奖5名…要不是我求情…SBill差点被分到三等奖那里…”“— —|||”听后，CKavel的脸上不自然地形成了一个川字。 “谢特…”SBill不自觉地叫了一声。“马萨嘎…被我说囧了…但是你也别放慢车速啊…”NCkr的脸上也出现了一个川字。“怎么了？”CKavel问道。“骚瑞…都怪我年少无知…信了那个在7F乱吹技术的家伙…装了一个油箱CLEO…呵呵呵…好像没油了…”SBill说着，无可奈何地晃了晃他那控制器。上面插着一个带显示器的U盘，显示器里写着“CLEO3注入器状态-车辆油箱CLEO:已加载” “WTF……看来SB你不经夸啊…车子我来开算了…”CKavel脸上的川字终于被挤成了一个水字，以迅雷不及掩耳盗铃之势和SBill交换了一个位置。“其实我一直不喜欢用NOS的…最BS玩LDZ开NOS的人了”“…不过这次算了”说着CKavel按下了NOS钮。随着一股蓝色火焰从车的排气管喷出来，立刻把身后的N.O.O.S.E防暴车甩开好远。“SB！你的CLEO除了油箱这一没用的东西还装了什么？”“Let me see see….哦，还装了一个尿尿CLEO、醉酒CLEO、跑酷CLEO、跳舞CLEO….没了，就这五个…都是从那个人那里要来的…”“卧槽…一个没用的都没有..醉酒尿尿跳舞用‘/’命令不就好了…但是那个跑酷…你等一下传给我吧…嘿嘿…”由于车速太快，脑袋壳儿磕到载物台挡板上的NCkr说话了：“卧槽…‘嘿嘿’那么猥琐的声音…嘿嘿什么的最讨厌了…嘿嘿…”“— —|||”坐在车厢内的CKavel和SBill脸上同时出现了川字。 不知不觉，他们已经到了CJ家附近了。而CJ也好像听说过这件事了，早早地派了一大帮“春哥帮”的成员，用汽车把整条街戒备了起来，随时迎接SNC三人和击退剩余的N.O.O.S.E。“春哥帮”，是CJ组织的帮派。他们帮派是一个曾经有过交警颁发的【连续十年无人违反交通规则】证书的遵纪守法的黑帮。平常也很少惹警察—–因为帮派成员精通各类潜入技巧，所以犯了事儿警察也找不到证据。 重聚三年过去了… 由于SNC三成员逃入LS城之后一直安分守己，也因为LS的警察们都不想惹祸上身，SB、NC、CK这三个曾经大闹乡村银行的小混混，竟慢慢地淡出了警察们的视野。 LS赤城山入口… “卧了个槽…”SB正蹲在他那残旧的AE86旁，看样子好像已经等了一个下午了。 “死NC…说好12点在赤城山赛一场的…KAO都晚上7点了还没来人…搞什么飞机…算了。打个电话，顺便骂死他。”于是SB熟练地拿出了CKR牌手机，关掉正在看的H，打开通讯录，用飞快的速度输入了‘N’字，选中了‘脑残’这个人，按下了通话键。 LS某大饭店… “无路赛~！无路赛~！无路赛~！”在饭店所有人的鄙夷的眼神中，一个穿着人字拖，军绿色短裤，桐乃痛T-shirt，还戴着大黑墨镜的小哥从屁股袋里掏出一只橙色的CKR牌俺妹痛手机，上面的少女字体一蹦一蹦地显示着“傻逼来电话了哟~！”的字样。这名小哥熟练地按下通话键，用娇娇的口音说道：“哦~是SB的电话呢…莫西莫…” “莫尼玛！尼玛不是说好了12点和我跑赤城的吗？！死哪去了？！”SB粗犷的声音怒不可遏。 “卧槽…不是午夜12点吗…现在在吃饭..”NC无辜地说道。 “KAO!我顶着个大太阳就开始等你等到了现在啊WTF…尼玛在吃饭…” “人家怎么知道了啦…” “限你半小时后给我死过来！”SB啪地挂了电话。 “唉…谁叫我那么抢手…没办法了…去吧…”NC付了钱悠闲地走出了饭店。 “大天黑的戴墨镜…神经病..”饭店里一老头说道。他头上戴的是金馆长的面罩。 “卧槽刚刚有一老头碉堡了…”NC发了一个群信息，转身跳进了一辆有着大得不像样的排气筒的Turismo里去了。直奔赤城。 “这样等下去也不是办法呢…哟西自己先跑一圈吧。话说好久没碰过86了…先熟练一下…”于是SB进车开启了引擎。空调口里吹来一阵凉爽的风。SB顿时泪流满面。“卧槽…一直蹲在外面等NC…早知在车里等…” 晚上7点半，一辆AE86，慢吞吞地一顿一顿地上了山。 “哦摸姨爹~ 那嗯~ 跌伊亚拉姨哟~~~”赤诚半山腰，一个开着定制版R8(粉红色)的帅小伙，收音机里听着很燃的音乐，正以飞快的速度漂移下山。正漂着，只见前方一辆老爷车横在路边。“卧…卧…卧槽！”帅小伙当机立断拉手刹，脚猛踩刹车，猛打方向盘，车子转了一个360度之后，停在了老爷车前面，差点没撞到。 帅小伙下了车，往老爷车走去。 “你个煞笔怎么开车的啊！车子竟然会被你开成这样！”正说着，帅小伙往车里一看，“卧槽…”只见SB从86里瞪着帅小伙。“这货真的是傻逼…”帅小伙停住了脚步。只见SB打开车窗，慢慢地说道：“死CK给我记住…以后骂人不要带SB…” 帅小伙从兜里拿出一包POCKR，边吃边说道：“SB那么晚横在路边干啥子？”“尼玛…老子今天改装了车子结果改崩了…哟西改回来了，快坐进来看我跑一圈。”SB说道。 “算了，”CK转身回去自己的车，“NC说他现在在赤城山下等我。他从我这借了俺妹特典借了3个月了，今天突然说要还给我，让我激动得都尿裤子了…我得赶快下去。” “噢噢，NC到了吗。哟西我也下山了。我们来比比谁下山快吧哈哈哈哈！”SB激动地叫着。 15分钟后… CK熟练地驾驶着R8华丽地漂下山后再来一个180度甩尾最后完美地停进了一个停车位，NC的Turismo就在旁边。 “yoooooooooooooooooCK!”NC激动地叫着。 “yoooo你妹。我的碟子呢，快还。”CK不吃这一套。 “什么嘛…真没情调…好吧好吧还给你..真是的…” “呜呜噢噢噢噢哦哦哦哦哦哦！终于回来了我的碟子！WTF这一阵什么气味…哎呀赶紧回家去。”CK激动坏了。 “喂喂别走先…我和SB要比赛，看吗？” 正说着，SB和他那86慢慢下来了。 “KAO你的4WD超跑让我怎么追得上啊KAO!”SB怒斥。 “要和我比的可是你…”CK无辜道。 “哟SB来啦！撒、来比吧！CK也来吗？”“算了…你们自己慢慢玩…我回家去。” 于是，SB，NC，CK三人，经过短暂的相聚，再度散去。 CK的大危机?!CK正在回家的路上…. “哟吓！被死NC拿去做奇怪的事情做了三个月的俺妹特典终于回来了…死NC害的这可爱的光盘沾上了一股奇怪的气味…WTF…”CK愤愤道。于是他重重地踩下了油门，好赶快回家把光盘用水冲一遍然后珍藏起来。 与此同时在赤城山顶… “尼玛FR怎么可能追得上4WD超跑啊靠！”SB开着他那AE86慢慢地上了山顶，NC已经在那里等了5分钟了。“要和我比赛的可是你…”NC说出了和CK一样的话。 “WTF…”SB明显不甘心。于是他掏出一颗白色的胶囊，狠狠地抛在了地上。面前立马出现了一辆FD。“你…你确定我俩还要比吗…”NC无奈道。“等等…CK来电话了。” “喂？NC你们还在赤城吧…赶快过来…我家…出大事了…”“啥…好吧…马上过去。” “嗯…快点…”CK按下了挂断键。而眼前，他的家里明显被人翻乱了。各种人物手办和抱枕乱撒一地。门前留了张长长的纸条。上面写道： “想必还认识我吧。上次你们仨赢了我，我很不甘心。今天来打算找你们重新赛一场，完成我的复仇。但是看你不在家，于是我就进门搜刮了一遍。还不错，找到了一个最新版的m0d。想要回来的话，下周六下午2点，LDZ见。” “KAO…”CK在风中凌乱。 “怎么了怎么了？”SB和NC火速赶到了现场。 “John留。”SB指着纸条最下面念到，“就是上次我们集训CK用小刀扔爆车胎的那个人吗…到现在还记得那事…” “嗯嗯…”NC若有所思。“看啊SB看别人约定时间是分上午下午的…没人像你那样傻X…” “NCNMGun…”SB选择无视NC。“对了…上面说的m0d…CK…你该不会…” “嗯…”CK看上去快哭了。“NC说要还我特典光碟…一时太激动忘了带m0d直接跑出来了…” “= =”SB从裆部掏出一支带显示器的U盘，“拿去吧…里面有齐了m0d基本上所有功能的CLEO…用这个吧…” “卧槽你还带着..”CK感激地收下了。CK在U盘的显示屏上翻看里面的内容，却顿时留下两行老泪。“功能好齐全…”这只小小的CLEOU盘里面几乎可以充当一个精简版的m0d，只是没有SNC最常用的R键B键和SHIFT键还有DELETE键。 “m0d我好想你…”CK现已泪流满面。 有危才有机没有了m0d的CK，就像是了魂一样落魄。 “CK,一起去秋明跑一圈吧！” “嗯…” “CK，一起去看猫猫片吧！” “嗯…” “CK，一起去看H吧！” “嗯…” “CK，把你的easyloli借给我H吧！” “嗯…” …… “这样也不是办法呢，”第二天早晨，SB和NC在幻想山半腰的某餐馆处，SB对NC说。 “嗯嗯。。要不我们仨去LDZ附近合宿吧，顺便练练车技，打败John。”NC提议道。 “哟西就这么干。” 第二天一早，SB跟NC带着半箱珍藏的萌萌loliH同人本，还有一个俺妹限量版的充气娃娃跑去CK家，硬是把CK给拽出门了。 “好吧好吧…看在俺妹充气娃娃的份上（吞口水）…我就勉强地跟你们出去了…”劝说CK出门所用时间：1分钟。 在NC亮出充气娃娃之后劝说所用时间：2秒半。 半小时后，SNC开始前往沙漠。 “呐呐SB，”CK饶有兴趣，“沙漠有啥好的旅馆吗？” “尼玛我是路痴别找我…”SB翻了翻白眼，“问NC去。” “我们不住旅馆…”NC说，“去一个朋友家寄宿。” “朋友？”SB失望地说，“肯定是那些满屋子充满工口气味的恶心宅吧…” 又过了半小时，在LDZ附近的一个乡村… “卧了个大槽…”当NC按下门铃，当SB看到开门的是一个穿着睡衣的可爱短发女生的时候，CK感叹道，“NC不可能私藏一个这么可爱的loli…”“ASS♂WE♂CAN”NC说道，“我妹妹..怎么样…” “呜呜呜哦哦哦哦哦哦哦哦哦哦哦哦哦哦哦！”CK一把冲上去抱住loli，边蹭脸边说道，“好可爱啊啊啊啊啊啊啊啊啊啊啊啊” “大哥哥…放…放开我…咳咳…放开..”loli看上去很辛苦。 “就不要”CK正要把手贴到loli的胸部，“平的好萌啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊” “法克！”只见loli把CK的手一拨，然后挣脱开CK的怀抱，转身一个飞踢，把CK踢进厕所去了。 “再碰我…”loli扣好睡衣扣子，轻声说道，“阉了你哦。” “哟西…”安排好床位后，SNC三人在房间里聊天，NC说道，“我妹妹…空手道二段…我都打不过她…” “逆天了…”CK揉了揉已经发紫了的肚子说道，“…不过这样的女生好可爱…” “尼玛…”SB鄙视地说，“这一脸享受的表情是怎么回事啊你这个M…” “话说这里离LDZ这么近，”NC提议道，“等下去LDZ耍耍吧。都三年没回来了。” “恩恩好好”SBCK都表示同意。 “大哥哥们，”NC的妹妹推开了SNC宿舍门，“出来吃午饭吧。” “呜呜噢噢噢噢哦哦哦哦哦哦过来让哥哥抱抱吧啊啊啊啊啊啊啊啊啊啊”CK冲了上去。 又是一个飞踢，CK又进了厕所。 吃饭时间…… “还没自我介绍呢，”NC妹说道，“我叫兔子。听NC说你们要在这里住一阵子什么的，请多多指教~” “叫你萌萌可以吗”CK打断道。 “…萌萌什么的..”兔子突然脸红起来，小声地说道，“…你去死吧。” 吃饭中… CK见兔子的碗里几乎没有菜，而桌上的菜都被SB和NC扫荡着。于是CK将自己碗里仅剩的一块烤土豆夹给了兔子。兔子脸红了。隔了很久才小声地说道，“谢…谢谢…”CK对着兔子微微一笑，说道，“吃吧。没关系的。”兔子的脸更红了，把头埋到了碗里。 “好可爱…”CK被萌到了。而SB和NC都只顾着自己吃饭，根本没注意到那么可爱的loli就坐在眼前。 “哟西，我们出发去LDZ了！”出行前，NC兴奋地说。“妹妹你就帮忙看家吧。” “看尼玛，你的家吗。”兔子强力吐槽道。 SNC三人一个接一个走出了大门。CK走在最后面。正要步出大门时，他感觉到后面有人拉着他的衣袖。“那个…出门…注意安全哦…” “放心。为了你我会安全回来的。”CK微笑着把手轻轻放在兔子头上。 “什…什么为了我之类乱七八糟的…”兔子的脸好红好红，“哥哥这个笨蛋…” 于是SNC一行人，正式向LDZ进发。 廉颇，老矣20分钟后，SNC一行人终于到了LDZ附近。 “LDZ真是越来越荒凉了…”开车的NC感叹道。“不靠GPS都不认得路了…” 去LDZ的路上，连半个人影都没有。一路上的风景除了黄沙满天，便是路上那些名贵跑车的残骸。 终于，SNC三人透过车窗看到了著名的大雷达和发夹弯。到了LDZ了。 “我们先来一场。”SNC三人各拿出一粒胶囊，往地上一扔。SB的还是86。NC的是大排气管TUR。CK的是粉红色的R8。“KAO…”SB忿怒地望着正在偷笑的NC和CK，“尼玛怎么都是4WD超跑…” “5…4…3…2…1…狗！”CKR牌手机就是好，还支持无线电对讲机功能，大伙儿用了都说好。只见NC第一个冲了出去。“死NC的臭习惯到现在还没改过来…”SB叫道，“甩尾都用NOS…”“亚…不只是NOS…”NC一边横着滑自己的车一边说道，“还用了ALT…”“尼玛要是我有m0d的话第一个R你…”CK怒斥。 三辆车，三名有着出神入化车技的车手，冲开了LDZ道路上沉积已久的灰尘。 半小时后，SNC三人在LDZ终点处。 “让我看看John是何许人…”SB用CKR牌手机上着网，“找到了…街头赛车手，主攻山路，秋名山赛道下坡记录保持者，保持了2年没人超过。他跑LDZ最好成绩是12分钟。” “我们呢？”CK插话道。 “26分钟…而且是全开NOS和ALT…”NC绝望地说。 “卧槽差那么远…”CK也绝望了。 “其实我们三年没跑过LDZ，这次跑能有26分算不错的了…”SB打气道。“我还以为我会迷路回不来了…” SB的一番话让NC和CK都看到了希望。“嗯…再差也有SB垫底…” “WTF…”SB看起来很受打击。 “弱爆了你们。”不知什么时候，LDZ上又来了一个人。只见他慢慢地开进停车位，帅气地从Bullet里面走出来。这位帅哥身穿真皮大风衣，带着大黑墨镜，帅气的站在NC身边，比NC高好几个头。“才三年没来就连弯都不会过了吗…” “哇…好高…”NC仰着头看着他。“而且我也有一副这样的墨镜…” “尼玛你忘了这墨镜之前我和你一起买的吗…”帅哥摘下墨镜说道。 “噢噢噢噢噢噢…你就是那个BB什么的…”SNC三人同时认出了帅哥。 “BB尼玛..”帅哥把手插进口袋，“是Bleach。” BleachBleach现身LDZ。 “BB,好久没见了。”“BB,有什么H好看的推荐没？…”“BB,最近有什么妹子介绍吗？…”SNC三人明显兴奋了。 Bleach，由于SNC三人连狗都不如的记忆力，被一直认为其名字是BB。业余赛车手。本身的职业是个卖鱼蛋的。但是一到午夜或者假期就会化身为开着黄色Bullet的墨镜帅哥。由于他的第一次比赛就击败了职业赛车手赛文打破了五年来幻想山下坡最快纪录，所以被人们称为“幻想山的黄色鱼蛋传说”。 “什么风把你们吹来了？”Bleach打断他们。 当SNC你一言我一语把整件事告诉Bleach之后，他重新戴上了墨镜，挥了挥手说：“大丈夫，萌大奶。每个人单独和我赛一场，结果有目共睹。” 于是，带着疑惑，SNC每个人都跟Bleach跑了一圈。结果除了SB是跟Bleach一起到的终点，NC、CK都远远超过Bleach一大截。 “哈哈哈哈哈哈哈”Bleach金馆长了一下。“LDZ的速度，你们不是都跑得不错嘛。” “你一圈用多久？”SB问到。 “9分半。没用NOS。”Bleach轻松地说到。 “卧槽…这么说我们…”CK难以自信。 “嗯…速度都碉堡了…”NC说。 “哟西..”SB说道，“难道你们都忘了我们仨以前被人称为什么吗…” 被这么一说，SNC三人顿时陷入了回忆之中…… LDZ的低空飞行三人组五年前的八月。热闹的LDZ打破了夏夜的宁静。这正是一年一度的市长杯山路竞速赛的第一站—LDZ赛区。这场比赛吸引了上百名参赛选手和来自全球各地的上万名观众现场观看。而收看电视直播的车迷们更是达到了百万。 “哇…人好多…”Kavel作为一名参赛者，也出现在了LDZ现场。这时的Kavel只是一名无聊的时候跑跑LV街道的小业余赛车手。虽说业余，但是他以前为了偷看在雷达站工作的可爱女生，已经跑了LDZ不下几千遍了，对LDZ赛道上每一条裂痕都了如指掌。 “那个…”突然Kavel从背后被人拍了一下肩。“请问…厕所在哪…” “不知道..问别人去…”Kavel没鸟他。 “好吧…”那人走开了。走路姿势好猥琐。 这人名叫CKR,也是参赛者之一。他给Kavel的第一印象就是猥琐。 “对了…看看观众里面有没有什么可爱的女生…”Kavel挤进了人堆中。 十分钟过去了… “呜哦哦哦…那个雷达站工作的女生也来了…好可爱…”Kavel从人群的缝隙中看到了对面有一个很可爱很可爱的短发女生，她使劲踮脚的姿势好萌好萌。于是Kavel有一种想把他从后面抱起来的想法。 正准备过去时，Kavel感觉到他后面又被人拍了一下。“又见面了呢…”还是之前那个猥琐小哥，不过旁边貌似还站着个人。“不知道厕所在哪对吧…他知道在哪…我也是刚刚才知道的…你也问问嘛…” “卧槽我为毛想要知道厕所在哪…”Kavel使劲吐槽道。 被CKR拉过来的人名叫Bill。他也是这次比赛的参赛者。原本他坐在自己的车里听着音乐玩手机。至于为什么被CKR给拉出来了，天知道。 一个小时后，听到大喇叭“各就各位”的声音后，每个人都坐进了自己的车。Kavel的车是天蓝色的Turismo。CKR的是某种很恶心的绿色的大排气筒Turismo。Bill的则是AE86。 “开始！”在刚开始的直道上，CKR首先就加速冲到了队伍的前面。而前面就是第一个发夹弯。“卧槽这个猥琐男快过弯了都不减速…”Kavel心想。距离第一个弯道越来越近，CKR却加大了油门，在入弯的时候甚至打开了NOS。“这货是新手吗…”Bill心想。CKR紧接着用一般人难以想象的角度擦边横着过了弯道。“卧…卧槽这货不要命了…”Bill惊叹道。出了弯之后CKR的车身由于悬挂系统左右猛烈晃动着。“卧槽以后别让我坐他的车…”Kavel感叹道。 CKR在耍宝，Kavel在他后面看得入神。Bill不知什么时候就跑到了第一位。 “那两个真的是新手…”Bill看着后视镜摇摇头说道。 接下来的几个发夹弯，带头的Bill华丽的漂移技术让后面的CKR和Kavel大吃一斤。“好…好厉害…” “…但是再厉害也只是86…”下了发夹弯，一大段的直路让Kavel和CKR的4WD大马力超跑级别的Turismo很轻易地超过了Bill的86，并把Bill挤到了第三位。“Fxxk…”SB愤怒地说道。 很快地，车队来到了水坝前的大坡度下坡加发夹弯。“卧槽完了…”CKR在入弯前习惯地按下了NOS键，才发现他的判断错了——下坡开NOS，毫无疑问是必死的。 辛亏CKR的功底不错，也只是稍稍地冲出了赛道一点。但是他还是被Kavel和Bill超过了。Kavel排到了第一位。 这种顺序几乎一直保持到了比赛的最后阶段。离LDZ只剩下最后一段直线了。Kavel望了望后视镜，发现Bill跟CKR并排跟在后面。 Kavel突然做出了一个决定。 稍稍向右扭了一下方向盘。 轻轻松了一下油门。 …… 市长杯山路竞速赛LDZ赛区，从左到右，Bill、CKR、Kavel三人，并列同时冲进了重点。 他们三人的成绩：2分50秒。 而第四个冲进终点的人的成绩，整整慢了他们10分钟。 …… 经过那场比赛后，他们三个被赛车界誉为“LDZ的低空飞行三人组”。 SNC三人，就是在这场比赛中认识的。 宝刀未老三少侠“我们…”CK突然回想起来了。“以前LDZ好像很快来着…” “ms你那过弯加速的臭毛病那时候就有了…”SB对NC说。 “ms你那总是用低马力FR车的臭毛病那时候就有了…”NC对SB说。 “我呢…我呢…”CK兴奋地问SB和NC。 “ms你那萌短发萌萌女生的臭毛病那时候就有了…”SB和NC异口同声。 “WTF…” “撒、接下来有什么事做呢…”刚吃完早饭，SNC就出了家门。现在他们仨坐在SB的AE86里摇摇晃晃地在沙漠里兜风。CK问到。 “凑时间等John跟我们决斗…”SB一语道破。 “卧槽…难道要等一个星期没事干…那我的连载怎么办…”CK一语道破+1. “什…什么连载…CK你说了个啥…”SB和NC的脸同时变成= =|||。 “WTF…没事了…”CK突然意识到什么，然后自觉闭嘴了。 “呐呐快看前面…”NC指着前方附近的乡村银行。“我们以前抢劫过这家银行吧…” “真怀念啊…要是我们再抢一遍的话…我觉得我们首先应该这样这样，然后这样这样，之后这样这样……最后从那面墙破一个大洞冲出来。”SB像军事顾问一样把全盘策略头头是道地说了出来。 Just like the old time. 正当SNC三人一脸陶醉的表情正在回忆过往美好的时光的时候，突然“嘭”的一声，SB说的那面墙突然炸开了一个洞。 “卧了个大槽…”当SNC三人看到了从洞里出来一个壮汉、一个猥琐和一个眼镜的时候，SNC三人的脸同时变成了= =|||。 “快看那三个…”CK说道。“嗯嗯…果然那个眼镜最帅…” “CKNMGun…”SB翻了翻白眼。 远处那三人，每人从口袋里拿出一颗胶囊，往地上一扔。壮汉扔出一辆ZR350，眼镜扔出一辆Inf，猥琐扔出一辆自行车。 “卧槽扔错了…”于是猥琐重新摸出一颗胶囊，又是一扔，扔出一辆摩托车。“卧槽我的TUR跑哪去了…”“草靠日快点…就用摩托算了…我们没时间了…”“好吧…”于是三人组坐上各自的车跑了。 “这仨是新手吗…”SNC脸上的川字早就变成了水字了。 “呐呐…”NC提议道，“不如我们把那三个都追上怎么样…” “哟西就这么做。”SB掏出遥控器按了按，那残旧的86立刻焕然一新。右侧车门的“SNC豆腐店（SB用）”字样变得闪闪发亮。 “依克做！”SB一按SHIFT键，汽车立刻浮在半空中。“哟吓！”NC打开了GPS装置。“开慢点..”CK第一次感到了没有遥控器的无助感。他坐在后排扣紧了安全带。 “= =|||||||”SB和NC都知道如果让CK拿m0d来开车他肯定会用ALT乱冲。 “NC，看到他们在哪里了吗？”SB手握遥控器上的摇杆说道。 “就在这里。”NC将GPS拿去给SB看了看。 “哟西我们就在他们前面一个街道的路旁守株待兔。”SB说道。 于是SB熟练地操纵着摇杆，操控着AE86在乡村的街道上穿行。 SHIFT的速度比想象中要快。当SNC他们早已到了目的地的时候，新手三人组才刚刚开过来。 “喂喂无机物…”在前方用ZR350开路的壮汉说道。“看前面那停着的86…刚刚我们好像才见过吧…”“好像是这样的…”眼镜表示同意。 与此同时在SNC那边… “准备好了吗？”SB有节奏地空踩着油门，左手摇晃着挡杆说道。 “3…2…1…ike!”CK透过后车窗看准了时机。 “轰！”随着引擎的怒吼，AE86突然从草丛中一跃而出，正好从ZR350的车前擦过。突然冲出的车把新手三人组吓得不轻。速度也立刻放慢了许多。SB熟练地驾驶着86很快地赶上了。 “比…比尔…”车队最后那个开摩托的猥琐叫道，“那…那辆破86想追上我们干嘛…” “破尼玛破！”SB怒道。只见SB左脚踩下离合，左手熟练地推上三档，右脚猛踩油门，从右边赶上了猥琐。NC和CK同时拉下了车窗。坐在前排的NC伸出手握住了摩托车的手把，后排的CK伸出手把猥琐一拉拉进了车里。 “卧槽！你…你们想干什…”话没说完，CK已经五花大绑把猥琐绑着扔到后备箱去了。“哟西！下一个！”CK叫道。 “哟西！”SB继续踩着油门。86在不断接近队伍中间的Infernus。这时CK拉开了86的车门。 “不行，还差一点！”CK叫道。SB松开油门，在一瞬间脚踩离合左手换挡。还没等油门踏板弹回来的功夫，车子稳稳当当地升到了四档。86渐渐和Inf并排了。换上四档后引擎的低鸣声中就可以听得出这台86改装FD引擎的马力完全比得上眼镜那台Inf的原厂4WD引擎，甚至更高。 “距离正好！我去了！”这时两辆车并排跑着。CK站在86的车门框上拉开了对面Infernus的车门，向后一蹬，从Infernus的右边跳了进去。CK在空中抓住了眼镜的脖子，俩人从Inf开着的车窗里飞了出来。 SB从后视镜看着CK飞进他们的车厢，轻点刹车，从Infernus的后面绕到了左边。猛踩油门，86的车身向后一倾，以极快的速度赶了上去，重新与Infernus的车头平行。 SB一把推开86的右车门，正好赶上了在空中旋转着的CK和眼镜。CK七百二十度空中转体带着眼镜一起钻进了86。整个过程一气呵成不带任何瑕疵。 眼镜明显被刚才发生的一幕吓到了，以至于CK用SM绑法绑住眼镜然后扔到后备箱，眼镜还一时没回过神来。 开路的壮汉估计也吓怕了。立刻减速。 SB拉手刹来个270度甩尾之后横向停在了ZR350前面。 “呐，骚年，”NC拿着GPS从86里出来，靠着车门帅气地说道， “要加入我们吗？” 阴谋壮汉颤抖着拉开了车门，刚离开驾驶座便腿软一屁股坐在了地上，望着86旁边的SNC三人发抖。“好…好厉害的驾驶技术…”“不算什么嘛…”SNC三人同时说道。“不不不NC你没资格搭话…从头到尾你就摸了一下摩托车把而已…看我那空中抓人加转体飞进车那才叫GJ…”“切…要不是有本B的神车技你们还能得瑟的起来吗…”说着，SNC自个儿吵起来了。新手三人组在一旁听着，脸上出现了大大的川字。 “让我们加入你们吧…！”眼镜的声音从后尾箱传了出来。待SNC将尾箱的两个解出来后，他们开始做自我介绍。眼镜：“我叫无机物…平时就有听说过你们的名字…你们其实一直是我的偶像..”壮汉：“我叫比尔…和无机物一起赛车的…直到某一天在发现了蹲在路边的草靠日…”猥琐：“叫我草靠日..我是看无机物和比尔有外挂才跟着他们的…” “呐呐..叫他们无比草怎么样…”“啥…那么恶心的名字..叫草比物吧…”“都不好听…还是SNC比较霸气…嗯嗯…”SNC早将三人无视了，在自己聊天。 “唔唔唔…可以加吗…”草比物三人问道。 “不能。”SNC三人异口同声。 “诶…？刚才那个很猥琐的明明还问要不要加的…”草靠日说道。 “说着玩的…”NC一脸坏笑。 于是SNC登上了SB的86一下子没了踪影，留下草比物在风中凌乱。 在路上… “呐呐你说我刚才会不会很欠打…”NC看着手机里的H问道。 “你一直很欠打…”SB说道。 “嗯嗯兔子好萌…”CK搭话道。 “WTF…”SBNC的脸出现了川字。 与此同时… 无机物的手机响了。屏幕显示着“JOHN”的字样。 “做得怎么样了？” “刚刚搞定。看样子他们还没意识到。” “不错。” 在不远处的一座蓄水塔上，JOHN挂断了电话，接着从口袋里拿出一个车钥匙一样的发射器。 CK的脖子后面，被粘上了一个很小的发着红光的接收器。 决战之日终于，决战之日到了。 在荒凉的沙漠上，此时的LDZ附近却热闹非凡。 整条赛道的两侧都挤满了各种大马力4WD超跑和专门来看比赛的群众。这种阵势已经很久没有见过了。他们想看的是John如何刷新LDZ新纪录，更想看的是“LDZ低空飞行三人组”成员CK的复出。 “如果哥哥赢了这场比赛，我就答应跟哥哥去约会…！”带着萌萌兔子的约定，CK带着一脸春风，和SBNC一起开着粉红色R8出门了。SB换上了他的FD，NC则开着一辆拖拉机。 到了会场后，鱼蛋小哥Bleach作为主持人讲述比赛规则：“整场比赛共三圈。赛道地图已经上传在每位选手手里的GPS装置上。在比赛中选手们在赛场上的位置将实时地显示在我身后的大屏幕上。现在还有半小时的准备时间，请选手们将GPS装置安装在车上。” “呜哇…好紧张…”安好装置后，CK在车里不断的想着兔子说的话，一边硬着一边通过CKR牌手机的无线电对讲功能和SBNC聊天。这时SB和NC已经坐上了直升机，准备在空中观看CK的比赛。NC甚至将他的CKR牌手机上的60000万像素摄像机功能打开，准备录下来。 “我的妹妹…死CK你性奋都来不及吧KAO…”NC流着泪说道。 “据我的观察，John也只是小角色一个。看他的车就知道了。”SB指着John的天蓝色zr350说道。 “加油…！！！”CK隐约地听见挡风玻璃外面有个好可爱的声音。一个短发loli在人群中跳动着，正是萌萌。 “嗯…我一定会跟你去约会的…”CK更硬了。在听到准备的提示后，CK慢慢放下手刹，轻轻踏着油门，平稳地开到起点处。 “准备了！”CK拉上手刹。 “3！”CK有节奏地踩着油门。 “2！”“轰隆…轰隆…” “1！”CK握紧手刹。 “GO！！！” 实力差距“GO！！！” 随着一声令下，GPS上的红色的背景色变成了绿色。这场轰动全SA的赛事，开始了。 “轰！”CK熟练地操控着R8，依靠4WD超跑改装版巨炮III引擎，从一起步就超出了原厂zr350一大截。 “Nice Start, ”SB在直升机上，作为NC的CKR手机摄像机解说，说道，“在恰到好处的35000转的时候半热起步，与CK改装的大马力引擎配合得天衣无缝。这样的技术可以让R8在0.26秒内从0加速到100km/h。使出如此绝妙的技术没有上万次的起步练习是不可能做到的。因为如果起步时再多1000转，起步就会变得极慢。而少1000转则会让车子在整场比赛都显得力不从心。”“只是…”SB话锋一转。 “LDZ开头是弯道，傻子。”John在天蓝色zr350里轻轻地说道。这时两辆车已经临近了LDZ的四连发夹弯。CK的车速过快，每过一个发夹弯都要猛拉手刹锁死轮胎才能甩尾过弯。“4WD超跑的致命弱点。”SB摇着头说道。这也是SB死也不肯用4WD的原因之一。跟在CK后面的zr350因为起步慢，在弯道很轻松地轻点刹车就漂过去了。JOHN的原厂zr350慢慢地赶上了CK的R8，并在第三个发夹弯用内侧漂移超过了R8。“谢特。。。”CK艰难地过着弯，看着John横着从R8旁边超过，气愤地说道。 看着zr350华丽地通过了发夹弯，而R8在10秒后也进入了主干道后，SB说道，“zr350的缺点，开始暴露了。” “直线加速太慢！”CK猛地换挡，大力踩下了油门。R8以不可思议的加速度冲了出去。长长的主干道，zr350用了40秒的时间。而R8仅仅用了8秒。R8又领先了zr350。 “John跑山路的技术实在了得，”SB用望远镜看着两人越拉越开，轻轻地说道，“可惜这里是LDZ。”面对干道尽头的弯道，CK显然做出了准备。在弯道前按了一个按钮，然后便松开了油门，只轻点几下刹车，车子便流畅的滑行过了弯。而速度也没有过多的降低。“CK自己研制的电子速度稳定器，通过装在刹车片上的装置，让入弯之前减少的动能储存起来，过完后再将储存起来的能量一次性爆发出来，以弥补过弯之后的速度不足，也减低了发动机的负荷。”SB解说道。 早已甩在后面的John看着R8逐渐消失的背影，愤怒的脸显得越发狰狞。他从抽屉里拿出一个无线电发射器，紧紧地握在了手里。 比赛还在继续着。 致命弱点CK依靠专业比赛用的巨炮III型超大马力版引擎，再加上几个月来一点一点亲自调教使得这个本身就有最强动力的引擎的性能又提升了好几个层次。现在这台引擎理论最大速度已基本达到了亚音速。这是原厂ZR350的引擎永远到达不了的境界。 眼看CK就要回到LDZ的四连发夹弯了。若CK现在减速到摩托车速度登山，最后的单圈成绩也能打破世界纪录好几十秒。 还在LDZ中段的John怒不可遏。他决定了。 他打开了发射器的盖子。 按下了开关。 “嘀——！” CK脖子后面的发着红光的亮点变成了绿色。 CK失去了知觉。 …… “呜哇…好多萌萌…跑过来了…” …… 坠落在LDZ终点… “快看，他们快到终点啦！” 好不容易从人群中挤出一点缝隙，“终于能看到哥哥那帅气的脸了…但是好害羞呀…”兔子微红的脸蛋透出期待的眼神，白嫩的双手在胸前紧紧攥着，看起来可爱极了。在CK入弯的一瞬间，她却看到CK的座椅后背映出了一丝绿光，CK随即倒在方向盘上，车子突然加速，冲破赛道的围墙，然后翻滚着冲出了悬崖，狠狠地撞向一百多米下的硬泥地。整部车被撞得反弹起来，然后再一次撞向地面，不断翻滚着前进。直到撞向外星饭店的大理石墙才勉强停了下来。车身毁坏的不成样子，玻璃碎片散落一地。等众人艰难地将CK从车内找出并救出来时，CK已全身骨折，没了心跳。兔子怔住了。她从小到大从未如此近距离的看过这么震惊的车祸，眼泪不自主地流了下来。她跪坐在地上，脸上写满了惊愕。 过了好一阵子后兔子才回过神来。“他死啦？不会吧？”她的心紧缩了一下。她站起身，拼命地奔向车祸现场，一直喊着CK的名字。 兔子发了疯似地拨开围着的人群，爬到CK跟前，看着全身是血的CK，一遍一遍喊着CK的名字，直到声音嘶哑、再也喊不出声音来了。兔子趴在CK的身上痛哭着。 不久，一辆救护车从远处开来，将CK的身体送上了救护车。兔子望着远去的救护车，双眼失神好久都没有缓过来。 不久，兔子的手机震动起来。是一条短信。上面写着：“放心。他还活着。” 暴露“咚！”随着一声巨响，CK的车子撞在外星饭店坚硬的岩石后墙上，停住了。车身被挤压得不成样子。就连直升机也被这声巨响震动了一下。 “NC, 看回放。”SB看着车子的残骸和John若无其事地冲向了终点，冷冷地说道：“这事不简单。” “+1。”NC调出录像，快进到CK入弯前的那个时间段，开始了慢放。 “看上去是CK突然失去意识了。”NC说道。画面在车祸前和车祸发生时的两个时间段不断重复着。 “等一下！”SB看了四遍慢放，突然好像发现了什么！ “你将那个画面放大50000倍！看看左边的观众席！”SB说道。 “兔子也在观众席——啊！不对！”NC突然也发现了什么！ “再放大一点！”放大后，他们终于确信他们看到的东西不是幻觉——兔子的眼睛里，映出了CK的座椅后背突然闪出了一点绿光！也是在同时，CK失去了知觉！ “有什么东西是可以使人在一瞬间失去知觉，然后陷入假死状态的？”SB问。 “掉线！”SB、NC异口同声地说了出来。 现在，两人终于知道事情的发展了。John请了草比物三人组出现在乡村银行，出演了那场戏，然后趁机将接收器安装在CK脖子后，然后在这一刻，让CK掉线！ “SB，掉线之后要多久才能重新联网？”NC问。 “看情况而定。CK应该要两个星期时间。”SB说。 “好。我叫人回收身体。全身骨骼替换需要一个星期。我们还有时间。可是我们还有更重要的事情要解决。”NC说。 “什么？” “杀了草比物，然后是John。” 草比物：处决凌晨1点20分，秋名山顶。一辆黑色面包车缓缓地驶来。籍着夜幕，没有人发现。 “杀了草靠日、比尔、无机物，今晚。”LEON最后看了一眼短信，按下删除键，然后抓起一个长长的黑色帆布包，从后门下车，登上了水塔。这里是LS城仅次于NMB大厦的最高的地方。而且地处偏僻，是个狙击的好地方。选这里当狙击点还有一个最重要的原因就是——比尔今晚将来这里飙车。 LEON将狙击步枪从帆布包里拿了出来。这支狙击步枪是LEON特制版，使用25MM口径贫铀穿甲弹，有效击杀距离为5KM。每个弹夹装6发子弹。 时间一点一点流逝，而LEON毫不着急。他趴在水塔顶部，身上用黑色布盖着，静静地等待着即将到手的猎物。 凌晨1点26分，秋名山底传来了引擎的轰鸣声。 “FD的声音。”又听到了急加速和急刹车强行甩尾的声音。“开车的人是比尔。”LEON轻声说道。 “5…4…3…2…1…就是现在！”LEON突然站了起来，用双手扛起70KG的重型狙击步枪，瞄准山下的亮光，计算好弹道和提前量，然后扣下扳机！ “砰！” “轰隆！” 山下突然爆炸了。一颗25MM贫铀穿甲弹从前方射入，射穿了FD的引擎和比尔的下半身，整辆FD翻了起来，在空中爆炸。 LEON转身，面向大海的方向。离秋名山2KM的海面上正在举行游艇聚会。无机物在里面。 “砰！” “轰隆！” 子弹贯穿游艇，无机物内脏全被穿入的子弹搅碎。游艇在海面上爆炸了。 LEON将瞄准镜对准夜空中的一点。600倍热成像瞄准镜准心正对着一架直升机上螺旋桨。 “砰！” “轰隆！” 草靠日的头颅被击穿，子弹穿过薄薄的钢板击断螺旋桨主轴，直升机应声失去控制，撞上了NMB大厦。 LEON放下狙击步枪，看了看手中的手表。 1点30分。 JOHN：策划午夜，6号仓库。一辆鱼蛋货柜车慢慢驶进。仓库卷帘门缓缓打开，货柜驶入仓库。卷帘门关上的一刹那，整间仓库全部灯都亮了起来。空旷的仓库有两个人迎面走向货柜车。戴墨镜的司机下了车。 “带来了吗？”“嗯。三件齐全的装备。”“好。” 三人中那个很壮的人搬来一张桌子。旁边的猥琐将一张大地图铺在桌面上。墨镜司机从包里拿出厚厚一叠资料。 “这个人叫John。27岁，身高一米七，不是本地人。七年前，因为参加春哥组织的猥琐夏令营而来到这里，但是却没有再回去过。他在SF一带名气挺广，听说是那里的Mr.J夜店老总，拥有一支装备精良的私人军队，还有贴身保镖六人，每一个都是特种兵出身。LEON以前也是特种兵，但是这六人的等级似乎比他更高一些。我们今晚可以去Mr.J夜店打探一下情况。”司机详细地说道。 “很好，”猥琐收起挤满桌子的本子和地图说道，“出发！” 三人打开货柜车箱，每人从里面拿出一件高科技潜行作战服穿上，然后关上灯，钻进货柜车。壮汉调好手臂上的GPS装置。上面有三个点在闪烁。壮汉的标识是SB，猥琐的标识是NC，司机的标识是Bleach。 司机打开车载电脑。“系好安全带。”司机说道。 他往电脑输入一段命令：“/tele Mr.J” “啪”一声，货柜车消失了。 JOHN：踩点SF的Mr.J夜店，一辆鱼蛋货柜车凭空出现了。不过，没有人发现。 货柜打开了，三个模糊的身影轻盈地下了车。 “打开匿踪模式。”NC通过加密无线电说道。 瞬间，三个模糊的身影消失了。如果不是走进特别仔细的观察的话，根本无法将他们从背景之中分辨出来。 分头行动。SB从正门进入，NC从二楼窗口爬入，Bleach从烟囱爬入。 十分钟后，他们聚集在了位于六楼的John办公室内部。 里面很安静。John坐在椅子上看书。浑然不知三人正在他的正前方凝视着他。 BL拔出.45消声手枪对准了他。 “要杀了他吗？”BL轻声说道。 “不杀。”SB回绝道。 “活捉。”NC回应道。 BL将手枪放回了枪袋。 突然，一阵电话铃声响了起来。John听着电话，神情越来越恐惧。 他按了一下桌子底下的按钮，保镖六人立刻出现了。 “听好，”John神情有点慌乱，“NMB就在刚才被处决了。我感觉他们会找上门来。从现在开始，Mark和Jack你们两个二十四小时随时贴身保卫我，剩下的人每天轮换岗位。不要让我失望。”“Yes, boss. ”对话间，SB看到了Mark往这边看了一眼。“别慌，不会暴露的。”BL轻声说。 “看来现在无望活捉了。”NC轻声说，“先回去商讨对策。” 不一会儿，SBNCBL三人在房间里一同消失了。 两分钟后，停在Mr.J门口的货柜车，也消失不见了。 骨骼重塑第二天清晨。NC开着他的绿色TUR，独自前往被称为69区的废弃军事基地。那里早已被俊花和野牛等一大堆世界顶尖科学家作为秘密科技研发中心。CK的身体正完好无损的保存在那里。 NC从裆部掏出IC卡，在门前一刷，进入了整个研发中心的核心地带。他在墙上拿起一件白大褂帅气的披在身上。上面的身份卡写着：“生物科技与医学研究院脑神经外科与人类非正常行为高级研究员CKR教授”。 “讨论得怎么样了？”“就等您了，教授。”NC让两个项目主管带路，通过长长的走廊，进入了会议室。 “教授，”一个年轻的科学家说道，“我们一致认为，使用生物陶瓷来重塑骨骼，这样就可以使目标醒后受到的痛苦最小，也能更快恢复体能。” “Nope. ”NC回绝道。“生物陶瓷实在太脆弱了。CK这样的特种战士，普通骨骼的强度根本不够。” “难道说……”另一个科学家说道。 “对。高强度钛铝合金。”NC说道。 “可是……” “确实。CK醒来之后会因为连接的身体和掉线前的身体在构造上有着巨大不同而需要经历难以忍受的极其痛苦的三分钟同步过程。但我相信他承受得住的，”NC摸着他的左手小臂说道，“如果让他自己做决定，我相信他也是这样选择的。” “但……”那名科学家还想反驳。 “他不是正常人。我相信他。”NC打断了他的话，脸上写满了信心。 “手术将在明天开始。散会。” 回归…… [2013/3/20 19:20:21]重新连接等待时间： 3秒 [2013/3/20 19:20:22]重新连接等待时间： 2秒 [2013/3/20 19:20:23]重新连接等待时间： 1秒 [2013/3/20 19:20:26]端口已打开。 [2013/3/20 19:20:26]输入/y开始连接。 [2013/3/20 19:20:28] [SNC]CKavel:/y [2013/3/20 19:20:29]请稍等… [2013/3/20 19:20:35]连接成功。正在与大脑建立映射… [2013/3/20 19:20:35][警告]映射建立因未知原因被暂停。 [2013/3/20 19:20:36][系统]你收到了一条信息。/o打开。 [2013/3/20 19:20:38] [SNC]CKavel:/0 [2013/3/20 19:20:39][系统]未知命令。 [2013/3/20 19:20:41] [SNC]CKavel:噗/0 [2013/3/20 19:20:42] [SNC]CKavel:/o [2013/3/20 19:20:44][新消息]CK：欢迎回来！你的身体已经被我们改进了。适应新身体将会有3分钟难以忍受的疼痛感，请做好心理准备。——NC 输入/r继续。 ……一段死亡般的寂静….. [2013/3/20 19:21:51] [SNC]CKavel:/r [2013/3/20 19:21:52][系统]映射重新建立，请稍等。 [2013/3/20 19:21:52][系统]映射成功建立。正在与身体进行同步… 秘密科技研发中心1号实验室，在NC、俊花、野牛等顶尖科学家的注视下，浸泡在水里的CK的身体开始了猛烈的抖动。扭动中的CK，脸上出现了极其痛苦的表情。 “心跳开始加快了！130.150.180.220.260.290.301.306！” CK剧烈的晃动着。在场的所有人当中，NC最紧张了。因为这种痛苦他是最清楚的。他的左手小臂上的骨骼正是高强度钛铝合金。 “心跳停止了！”随着实验室空中回荡着的“嘀——”的声音，CK也停止了晃动。 NC痛苦的闭上了眼。“果然…全身还是不行吗…” 突然，CK的心脏跳动了一下！ NC睁开泪眼，双手紧紧的抓着栏杆。 现场所有人都震惊了！ “嘀…嘀…”CK的心跳慢慢恢复了。 现场所有人都欢呼了起来。 CK回归了。 JOHN：重新策划两天后，LV市立医院。 CK张睁开了模糊的双眼。 “嗯。。。” 趴在床边睡觉的SB闻声醒来了。“太好了！”他点亮呼叫按钮。“护士！CK醒啦！” 很快地，一名护士进来了。紧跟进来的是兔子、NC、Bleach和LEON。兔子消瘦的脸庞终于找回了昔日的光彩。 “哥哥~！！！”兔子一下趴在CK身上，大哭了起来。 “呐…我们先出去一下吧…”NC苦笑地说。 “我同情你…”SB拍了拍NC的肩。“走吧…楼下百事我请客…” “我要冰红茶…”NC被SB带领着，垂头丧气地走出了病房。 医院餐厅。 “之前的计划，现在可以实施了。”NC看着手中两罐旺仔牛奶开心得像个孩子，似乎忘却了刚才悲伤的记忆。SB坐在饭堂凳子上说道。 “还是先叫齐人。”SB打开CKR牌手机拨弄着。不久，野牛和俊花赶来了。野牛上身穿着西服，下身穿了一条短裤和人字拖。俊花是白背心混搭牛仔裤。看到这两人以后餐厅里所有人都躲得远远的。 于是在拥挤的医院的餐厅里，六人得以霸占了一张长桌子。 NC摊开大地图。SB说道：“我们再说一遍计划。听好，我们这里六个人，”他将John贴身保镖六个人的照片撒在桌子上，“我们每人盯梢一个人，把它做掉，然后伪装成他们，接近John的身边，活捉John。然后剩下的事情就交给CK了。” 每人都挑了一张照片。 “你们什么时候能准备好？”NC问。 “1个星期吧。”LEON说。 “好。一个星期后6号仓库见面。”SB说。 “该上去了。走吧。”NC喝了一大口旺仔牛奶，擦了擦嘴说。 其他人先走了。剩下NCSB上去5楼病房。 后来，推开门见到病房里脸好红好可爱的兔子背对着门在穿衣服和CK那好满足好猥琐的表情后，NC跑了。 中计终于，一个星期到了。 凌晨3点。空无一人的Mr.J夜店停车场保安室里摆满了监控录像屏幕。其中一个小屏幕里正在放映着停车场1号监控镜头的实时画面。 外面正在下大雨，地上全是积水。一辆白色的货柜车突然凭空出现了。后车箱自动打开了，但过一会儿却自动关上了。车箱下的地面那滩原本平静的积水此时却多出了6双脚印。其中一双脚印慢慢地朝着监控镜头走近。脚印上方的空气露出一把碳纤维.45消音手枪。枪口闪了一下，监控镜头便失去了信号。 Mr.J三楼，John私人军队的宿舍。 “MLGB喝咖啡喝多了。。。”一名胸前挂着“Jack”的士兵边捂着JJ边往厕所走去。“都6000天没有睡觉了。。。”不远处，开着m0d隐身力场的NC从屁股里抽出一把40CM长的碳钢打刀悄悄的跟了上去。 厕所。NC悄悄地推开门。 而里面却空无一人。 “WTF..?”NC小声说着，从潜行的半蹲姿势站起身来，关闭了隐身力场。 突然，NC感到背后有一阵风袭来。 幸亏NC受过专业训练，在黑影距离NC后脑勺仅有5CM的时候觉察到并只用了0.08s便提手用刀身挡住了黑影直刺过来的螺丝刀。 “身手不错嘛，”黑影冷笑道。“不过没有子弹快。” “WHA。。。”NC双眼睁大。黑影的腰间闪出了.45消音手枪的反光。 还没等NC反应过来，“噗”一声闷响，NC肾中弹了。 NC在极大的疼痛之中渐渐失去了力气，手中的碳刀滑落地上。NC倒在了厕所地上，伤口流出好多血。NC的视野渐渐发黑。 在NC渐渐失去意识时，他隐隐约约地听见耳机里传来SB断断续续的喊声：“我们暴露了！快取消计划！快取消计划！快。。。嘭！沙沙沙沙。。。。” 凌晨3点40分，Mr.J夜店停车场，积水上有两双脚印慢慢地走到白色货柜车旁，车门打开，然后自动关上。接着整辆货柜车，消失在了黑暗中。 …… [2013/3/29 3:42:16][系统]欢迎[SNC]Bleach回到LV城。 [2013/3/29 3:42:16][系统]欢迎[SNC]LEON回到LV城。 CK躺在LV市立医院的大床上，身旁依偎着可爱的兔子。 “呐，你说我哥哥他们做完这次任务一定能回来我们身边的对吧？”看着电视左下角的两行回城欢迎信息，兔子说道。 “放心好了。他们厉害得很呢。”CK说着，把兔子一把搂在怀里，慵懒地闭上了眼。兔子枕着CK的手臂，两人一起又进入了梦乡。 瓮中之鳖“谢特…”野牛在通风管道里通过无线电听到了SB的叫喊，在内心叫道。 “这个频道已经被监听了…”俊花在女生澡堂通过无线电听到了SB的叫喊，在内心想道。 于是凭借着他们多年猥琐的默契，野牛和俊花同时将通话频道调成了“52694”。 “下一步怎么办？”野牛说道。 “先想办法回医院。CK可能有危险。”俊花小声地说，旁边传来女生的笑声。 “MLGB难怪他们找不到你…你都去的哪…”野牛吐槽道。 凌晨4点10分，LV市立医院停车场。一辆白色面包车缓缓驶入。 CK越睡越不安。他的脑海里浮现出的是刚才电视的欢迎信息。 “NCSB野牛俊花呢？” CK猛然睁开眼，先帮熟睡中的兔子盖好被子，转身拿起床头的SNC特制版镀银M1911，装上消音器，然后转身出门，锁好病房，靠在电梯门口一侧静静地守着。 白色货柜车停好后，LEON和Bleach从车上下来。Bleach拔出了碳钎维.45消音手枪，LEON收起NC的碳刀，两人走进了LV市立医院。 背叛电梯缓缓上升… “1…2…3…4…5…叮！” CK紧握着枪把，吞了一口唾沫。 门打开了。Bleach从里面出来，径直走向病房。 随后的LEON刚一出来便被CK劫持住了。 “BL!我TMD在这里！”CK大叫道。 Bleach被身后突如其来的吼叫吓到了。 “很聪明嘛，”Bleach定了定神，缓缓转过身来。 Bleach向LEON使了一个眼色，LEON右手伸到背后抽出碳刀一个转手往CK的肚子上划了一个大口子，然后向后一推，CK痛苦地向后倒去。 LEON一脚将CK手里的M1911踢掉，然后走到一边。 “你。。。那把刀。。。NC他。。。”CK忍着痛大口大口喘气道。 “NC? 啊，恐怕早已在厕所里被老鼠吃掉了吧！”Bleach放肆地笑着。 “还有你的SB，我可是亲眼看着他被我的特制手榴弹炸得四分五裂呢。”LEON平静地说着。 Bleach缓缓举起手中的.45消音手枪，打开了保险。 “艹…”CK倒在地上，痛苦地说，“为什么…” “因为我和Bleach从一开始就是JOHN手下的人。”LEON平静地说。 “大家都只是打一份工而已。”Bleach右手食指慢慢地伸到扳机上，慢慢扣紧。 “对不起了。” CK绝望地闭上了眼。 “啊~！！”“什么？！” “噗！”“Biu！” …… 以下全部事件发生在20秒以内“啊~！！”“什么？！” “噗！”“Biu！” 子弹擦着CK的头发噌地飞过去。 CK猛地睁开眼，应激运至全身的肾上腺素使他获得极快的反应速度。 眼前的景象仿佛全都静止了。CK看到兔子正浮在半空中，右脚狠狠地揣在Bleach的脸上。Bleach也浮在空中，失去重心的Bleach正在空中做着斜抛运动。一旁的LEON还没意识到眼前的一切，正打算转身回头看。 CK猛地一个鲤鱼打挺，整个身体顺势前空翻180度，接着单手撑地来了个托马斯回旋甩腿正中LEON的脸，另一只手向前夺刀然后用刀背狠狠地敲了一下LEON的头，LEON还没意识到眼前的一切就昏了过去。 CK抬头一瞥，竟发现Bleach正掐着兔子的脖子举到了半空中。虽然兔子脚法一流，但是在身高与体格方面注定不不上186壮汉Bleach。 CK没有多想，直接将手中的刀甩了出去。 NC的碳钢大打刀，在空中旋转数圈，径直插中了Bleach的右眼。 Bleach当场死亡。 4时50分，LV市立医院5楼。 一个瘫倒在地上喘气的女孩，一个跪在地上全身肌肉绷紧的男人，一个扬起菊花昏迷了的男人，还有一个倒在血泊当中的男人。 血战：前夕“法克…他们先来了一步…” 5点整，俊花和野牛骑着三轮车气喘吁吁地出现在LV市立医院大门口。 “诶！快看大门！” 医院门被推开了。CK满身是血、由兔子搀扶着慢慢走出大门。CK见到野牛和俊花，冷冷地说道：“杀回Mr.J。” 俊花赶紧调出m0d给CK刷一个血包，野牛掏出胶囊往地上一扔，一架直升机立刻出现在医院空地。 “我也可以去战斗吗？”兔子轻声地说，“我想为哥哥复仇。” “嗯。”CK信赖地看着她，“片甲不留。” 四人登上直升机，直升机腾地一下升空了。临走时，俊花打开他的CKR牌手机，输入“/tp LEON car /tp Bleach car”，野牛操控着直升机缓缓地对准了停车场上唯一的白色面包车，按下操纵杆，6000发“地狱火改”小型战术核弹从直升机两侧飞出，向那辆面包车疯狂喷泄着。 野牛一拧操纵杆，直升机转头朝Mr.J方向飞去。 与此同时，Mr.J夜店… “法克…” 在熊熊烈火中，一个壮汉一把推开身上的钢筋水泥天花板，站起身来，拍拍身上的尘土，然后从屁股袋里拿出一支POCKY，随意地伸到旁边的烈火上烤了一圈，然后一口把整根POCKY吃掉了。 SB的复仇“…他大概死也不会知道我装了无敌CLEO…” 壮汉看了看插在裆部的U盘，轻轻说道。 壮汉轻轻地捏了一下裆部，伸手便从里面掏出一把MINIGUN。接在上面的蓝色弹药箱上写着一行字“SB私改TNT弹”。这种弹药每发杀伤力相当于700kgTNT爆炸所造成的威力。而枪身使用了SB自制微秒级发射单元和电子后坐力稳定器，可以让此枪在0.1s内发射出最多4000发子弹而枪身最多只抬高0.003mm。 “IT’S TIME TO PAYBACK! ” “轰隆隆隆隆…” 30km开外，CK一行人便听到了SF城传来的一阵阵闷响。 “打雷了？”兔子问。 “不，是俊花放屁了。”野牛答。 “尼玛卖批…”俊花下意识地挪了挪屁股，“老子刚放那个没声音…” “MLGB!”CK打开窗户，“怪不得刚才臭到爆炸还以为生化危机了…” “嘭嘭嘭！” Mr.J夜店里到处是烧焦的残肢和爆炸的痕迹。SB一路杀过去，到达了NC被伏击的厕所门前。 SB猛地撞开门把躺在地上的NC抱起搭在肩膀上，又杀了出去。 烧焦的尸体旁，破碎的电视左侧隐隐约约显着几行红色的字。 “[SNC]SBill 90连杀！” “[SNC]SBill 100连杀！” “[SNC]SBill 200连杀！” 我把你们包围了Mr.J夜店火光熊熊。SB一脚踹飞大门，肩扛着NC从里面走出来。 “谁敢和我决一死战！” 一声大吼，SB朝着包围着夜店大门的私人军队装甲车和躲在车后不敢露出半个头的雇佣兵疯狂地倾泻着子弹。SB私改TNT子弹冲击力就是强，竟然能把重量达90T的移动要塞装甲车从正面打翻，并且一路翻滚掉进旁边的海里，激起几米高的水花。装甲车全都被打进水里了，雇佣兵们见没有了掩护，纷纷四处逃窜。 SB哪里肯罢休，于是扔掉NC右手抽出一把西瓜刀，左手伸进裆部，轻轻一捏，立刻瞬移到逃得最慢的士兵身后，对着脖子就是一划，士兵应声倒地。SB一捏裆部，瞬移到另一士兵身后，再一捏裆部，又瞬移到另一士兵身后。SB捏裆部的频率变得飞快，SB以超过光速的速度瞬移在每一个士兵的身后，就好像SB影分身之术。 士兵们看着彼此身后好像都有一个SB在跟着，不由得吓破了胆，跑得更快了。 SB大喊一声“我已经把你们包围了！”手起刀落间，8000多名四处逃窜的雇佣兵，几乎在同时应声倒地。苍白的天空顷刻被殷红的鲜血染蚀。 SB最后瞬移回到了NC身边，右手把NC从地上搂起来，左手从裆部抽出一把自动伞，轻轻一按，自动伞喀的一声撑开了。SB将伞向右稍稍一倾，帅气地为NC遮挡天上落下的血雨。 过了没多久，野牛开着直升机飞来了。SB看到了金门大桥上方那摇摇晃晃的黑点慢慢变大，轻轻笑了一声，便倒在了地上。 “啊，野牛的开飞机技术还是那么的水。” 全面开战“嘟嘟嘟嘟嘟嘟嘟嘟…” 直升机摇摇晃晃地降落在Mr.J门前，一片血红色的大空地上。舱门猛地一打开，兔子跳下舱门就弯腰呕吐起来。CK站在兔子身后拍着她的背，俊花、野牛则奔向失去知觉倒在血泊中的SB和NC。 野牛往他的CKR牌智能手表上飞快地输入“/give SB health /give NC俺妹H” SB勉强地醒来了。NC的下面也很精神。 SB双手撑在地上问野牛，这是怎么一回事？ 俊花把NC被Bleach夺走的碳刀拿了出来，晃了一晃，上面的血迹在碳钢表面的哑光上清晰可见。 野牛说，是LEON和Bleach。John远比我们厉害得多。 SB盯着NC精神的下面，脸上的凶气越发浓重。 CK和兔子在吐完以后，也走了过来。 野牛往他的CKR牌智能手表上飞快地输入“/tp NC LOVEHOTEL”，NC啪地一声消失了。 “Time for payback. 这次是为了NC。” 五人重新登上了直升机。这次是SB在开。 等直升机飞过了金门大桥，SB掏出CKR牌手机，给“10086”打了个电话。 “指令已接受。”电话那头温柔的女声说到。就在这时，Mr.J的上空像雨点一般降下上万颗小胖子核弹。“嘭嘭嘭嘭嘭！”，Mr.J发出了连续而巨大的爆炸，5层高的大楼分解成无数尘埃往四面八方炸开。整栋大楼转眼间消失殆尽，只剩下地上厚厚的粉尘。 …… [2013/3/29 6:00:00][系统]欢迎JOHN回到SF城。 [2013/3/29 6:00:08] JOHN:。 [2013/3/29 6:00:18] JOHN:/admin login admin [2013/3/29 6:00:19][系统][管理员]登陆中… [2013/3/29 6:00:26][系统][管理员]欢迎你，管理员[ADMIN]JOHN。 （全文完）","link":"/zh-CN/snc-revengence.html"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"app","slug":"app","link":"/tags/app/"},{"name":"GTD","slug":"GTD","link":"/tags/GTD/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"Greedy","slug":"Greedy","link":"/tags/Greedy/"},{"name":"Hashmap","slug":"Hashmap","link":"/tags/Hashmap/"},{"name":"Premutation","slug":"Premutation","link":"/tags/Premutation/"},{"name":"Tricky","slug":"Tricky","link":"/tags/Tricky/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"Backtrack","slug":"Backtrack","link":"/tags/Backtrack/"},{"name":"DFS","slug":"DFS","link":"/tags/DFS/"},{"name":"Triky","slug":"Triky","link":"/tags/Triky/"},{"name":"Manacher's Algorithm","slug":"Manacher-s-Algorithm","link":"/tags/Manacher-s-Algorithm/"},{"name":"Binary","slug":"Binary","link":"/tags/Binary/"},{"name":"site","slug":"site","link":"/tags/site/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"framework","slug":"framework","link":"/tags/framework/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"games","slug":"games","link":"/tags/games/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"reviews","slug":"reviews","link":"/categories/reviews/"},{"name":"logs","slug":"logs","link":"/categories/logs/"},{"name":"programming","slug":"programming","link":"/categories/programming/"},{"name":"articles","slug":"articles","link":"/categories/articles/"}]}